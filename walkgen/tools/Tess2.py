# Generated by Haxe 4.0.5
# coding: utf-8

# > SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
# >
# > Copyright (C) [dates of first publication] Silicon Graphics, Inc.
# > All Rights Reserved.
# >
# > Permission is hereby granted, free of charge, to any person obtaining a copy
# > of this software and associated documentation files (the "Software"), to deal
# > in the Software without restriction, including without limitation the rights
# > to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# > of the Software, and to permit persons to whom the Software is furnished to do so,
# > subject to the following conditions:
# >
# > The above copyright notice including the dates of first publication and either this
# > permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
# > included in all copies or substantial portions of the Software.
# >
# > THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# > INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# > PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
# > BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# > TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
# > OR OTHER DEALINGS IN THE SOFTWARE.
# >
# > Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
# > be used in advertising or otherwise to promote the sale, use or other dealings in
# > this Software without prior written authorization from Silicon Graphics, Inc.
# >
# > Copyright (c) 1994 Eric Veach
# >
# > Copyright (c) 2013 Mikko Mononen
# >
# > Copyright (c) 2014 Giuseppe Di Mauro (azrafe7)


import sys

import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import re as python_lib_Re


class _hx_AnonObject:
    _hx_disable_getattr = False

    def __init__(self, fields):
        self.__dict__ = fields

    def __repr__(self):
        return repr(self.__dict__)

    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None

    def _hx_hasattr(self, field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self, tag, index, params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["split"]

    def __init__(self, r, opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r, options)

    def split(self, s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern, s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s, lastEnd, x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x3 = HxString.substr(s, lastEnd, None)
            ret.append(x3)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern, s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s, 0, self.matchObj.start()), HxString.substr(s, self.matchObj.end(), None)]


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o, field):
        return python_Boot.field(o, field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c, 0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or
                         ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or
                    ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self, it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has


class hxGeomAlgo_Debug:
    _hx_class_name = "hxGeomAlgo.Debug"
    __slots__ = ()
    _hx_statics = ["assert"]

    @staticmethod
    def _hx_assert(cond, message=None, pos=None):
        return


class hxGeomAlgo_HomogCoord:
    _hx_class_name = "hxGeomAlgo.HomogCoord"
    __slots__ = ("x", "y", "w")
    _hx_fields = ["x", "y", "w"]
    _hx_methods = [
        "add", "sub", "neg", "mul", "div", "normalize", "lengthSquared", "length", "perp", "dotPoint", "dot",
        "perpdot", "dotperp", "equals", "left", "right", "toScreen", "toPoint", "meet", "meetPoint", "toString"
    ]
    _hx_statics = ["INFINITY", "det", "ccw", "cw"]

    def __init__(self, x=None, y=None, w=None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 1
        self.x = x
        self.y = y
        self.w = w

    def add(self, p):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p.y)
        _hx_local_2.y
        return self

    def sub(self, p):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 - p.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 - p.y)
        _hx_local_2.y
        return self

    def neg(self):
        self.w = -self.w
        self.x = -self.x
        self.y = -self.y
        return self

    def mul(self, m):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.w
        _hx_local_0.w = (_hx_local_1 * m)
        _hx_local_0.w
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.x
        _hx_local_2.x = (_hx_local_3 * m)
        _hx_local_2.x
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 * m)
        _hx_local_4.y
        return self

    def div(self, m):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.w
        _hx_local_0.w = (_hx_local_1 / m)
        _hx_local_0.w
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.x
        _hx_local_2.x = (_hx_local_3 / m)
        _hx_local_2.x
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 / m)
        _hx_local_4.y
        return self

    def normalize(self):
        return self.div(self.length())

    def lengthSquared(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        v = self.lengthSquared()
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    def perp(self):
        tmp = -self.y
        self.y = self.x
        self.x = tmp
        return self

    def dotPoint(self, p):
        return ((self.w + ((self.x * p.x))) + ((self.y * p.y)))

    def dot(self, p):
        return (((self.w * p.w) + ((self.x * p.x))) + ((self.y * p.y)))

    def perpdot(self, p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def dotperp(self, p):
        return ((-self.x * p.y) + ((self.y * p.x)))

    def equals(self, p):
        if ((p.w * self.x) == ((self.w * p.x))):
            return ((p.w * self.y) == ((self.w * p.y)))
        else:
            return False

    def left(self, p):
        return (self.dotPoint(p) > 0)

    def right(self, p):
        return (self.dotPoint(p) < 0)

    def toScreen(self):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new((self.x / self.w), (-self.y / self.w))

    def toPoint(self):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new((self.x / self.w), (self.y / self.w))

    def meet(self, p):
        return hxGeomAlgo_HomogCoord(((p.w * self.y) - ((self.w * p.y))), ((self.w * p.x) - ((p.w * self.x))),
                                     ((self.x * p.y) - ((self.y * p.x))))

    def meetPoint(self, p):
        return hxGeomAlgo_HomogCoord((self.y - ((self.w * p.y))), ((self.w * p.x) - self.x),
                                     ((self.x * p.y) - ((self.y * p.x))))

    def toString(self):
        return ((((((" (w:" + str(self.w)) + "; x:") + str(self.x)) + ", y:") + str(self.y)) + ")  ")

    @staticmethod
    def det(p, q, r):
        return (((p.w * q.perpdot(r)) - ((q.w * p.perpdot(r)))) + ((r.w * p.perpdot(q))))

    @staticmethod
    def ccw(p, q, r):
        return (hxGeomAlgo_HomogCoord.det(p, q, r) > 0)

    @staticmethod
    def cw(p, q, r):
        return (hxGeomAlgo_HomogCoord.det(p, q, r) < 0)


class hxGeomAlgo_HxPointData:
    _hx_class_name = "hxGeomAlgo.HxPointData"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["toString"]

    def __init__(self, x=None, y=None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def toString(self):
        return (((("(" + str(self.x)) + ", ") + str(self.y)) + ")")


class hxGeomAlgo__HxPoint_HxPoint_Impl_:
    _hx_class_name = "hxGeomAlgo._HxPoint.HxPoint_Impl_"
    __slots__ = ()
    _hx_statics = [
        "EMPTY", "get_x", "set_x", "get_y", "set_y", "_new", "setTo", "equals", "clone", "toString", "fromPointStruct",
        "toPointStruct"
    ]
    x = None
    y = None

    @staticmethod
    def get_x(this1):
        return this1.x

    @staticmethod
    def set_x(this1, value):

        def _hx_local_1():

            def _hx_local_0():
                this1.x = value
                return this1.x

            return _hx_local_0()

        return _hx_local_1()

    @staticmethod
    def get_y(this1):
        return this1.y

    @staticmethod
    def set_y(this1, value):

        def _hx_local_1():

            def _hx_local_0():
                this1.y = value
                return this1.y

            return _hx_local_0()

        return _hx_local_1()

    @staticmethod
    def _new(x=None, y=None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        this1 = hxGeomAlgo_HxPointData(x, y)
        return this1

    @staticmethod
    def setTo(this1, newX, newY):
        this1.x = newX
        this1.y = newY

    @staticmethod
    def equals(this1, p):
        if ((p is not None) and ((this1.x == p.x))):
            return (this1.y == p.y)
        else:
            return False

    @staticmethod
    def clone(this1):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(this1.x, this1.y)

    @staticmethod
    def toString(this1):
        return (((("(" + str(this1.x)) + ", ") + str(this1.y)) + ")")

    @staticmethod
    def fromPointStruct(p):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(p.x, p.y)

    @staticmethod
    def toPointStruct(this1):
        return _hx_AnonObject({'x': this1.x, 'y': this1.y})


class hxGeomAlgo_PolyTools:
    _hx_class_name = "hxGeomAlgo.PolyTools"
    __slots__ = ()
    _hx_statics = [
        "point", "zero", "EPSILON", "isCCW", "isCW", "makeCCW", "makeCW", "isConvex", "isSimple", "segmentIntersect",
        "findDuplicatePoints", "intersection", "isReflex", "at", "wrappedIdx", "side", "isLeft", "isLeftOrOn",
        "isRight", "isRightOrOn", "isCollinear", "distance", "distanceToSegment", "distanceSquared",
        "distanceToSegmentSquared", "getCentroid", "getArea", "meet", "dot", "sqr", "eq", "clear", "toFloatArray",
        "reverseFloatArray", "flatten", "toPointArray", "parsePoints", "inflateLine", "clip", "lerp", "lerpPoints",
        "exposeEnum"
    ]

    @staticmethod
    def isCCW(poly):
        if (len(poly) <= 2):
            return True
        signedArea = 0.
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            idx = (i - 1)
            idx1 = idx
            _hx_len = len(poly)
            if (idx1 < 0):
                idx1 = (idx1 + _hx_len)
            idx = HxOverrides.mod(idx1, _hx_len)
            idx2 = (i - 1)
            idx3 = idx2
            len1 = len(poly)
            if (idx3 < 0):
                idx3 = (idx3 + len1)
            idx2 = HxOverrides.mod(idx3, len1)
            signedArea = (signedArea + ((((poly[idx] if idx >= 0 and idx < len(poly) else None).x *
                                          (poly[i] if i >= 0 and i < len(poly) else None).y) -
                                         (((poly[i] if i >= 0 and i < len(poly) else None).x *
                                           (poly[idx2] if idx2 >= 0 and idx2 < len(poly) else None).y)))))
        return (signedArea < 0)

    @staticmethod
    def isCW(poly):
        if (len(poly) <= 2):
            return True
        signedArea = 0.
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            idx = (i - 1)
            idx1 = idx
            _hx_len = len(poly)
            if (idx1 < 0):
                idx1 = (idx1 + _hx_len)
            idx = HxOverrides.mod(idx1, _hx_len)
            idx2 = (i - 1)
            idx3 = idx2
            len1 = len(poly)
            if (idx3 < 0):
                idx3 = (idx3 + len1)
            idx2 = HxOverrides.mod(idx3, len1)
            signedArea = (signedArea + ((((poly[idx] if idx >= 0 and idx < len(poly) else None).x *
                                          (poly[i] if i >= 0 and i < len(poly) else None).y) -
                                         (((poly[i] if i >= 0 and i < len(poly) else None).x *
                                           (poly[idx2] if idx2 >= 0 and idx2 < len(poly) else None).y)))))
        return (signedArea > 0)

    @staticmethod
    def makeCCW(poly):
        reversed = False
        if (not hxGeomAlgo_PolyTools.isCCW(poly)):
            poly.reverse()
            reversed = True
        return reversed

    @staticmethod
    def makeCW(poly):
        reversed = False
        if hxGeomAlgo_PolyTools.isCCW(poly):
            poly.reverse()
            reversed = True
        return reversed

    @staticmethod
    def isConvex(poly):
        isPositive = None
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            lower = ((len(poly) - 1) if ((i == 0)) else (i - 1))
            middle = i
            upper = (0 if ((i == ((len(poly) - 1)))) else (i + 1))
            dx0 = ((poly[middle] if middle >= 0 and middle < len(poly) else None).x -
                   (poly[lower] if lower >= 0 and lower < len(poly) else None).x)
            dy0 = ((poly[middle] if middle >= 0 and middle < len(poly) else None).y -
                   (poly[lower] if lower >= 0 and lower < len(poly) else None).y)
            dx1 = ((poly[upper] if upper >= 0 and upper < len(poly) else None).x -
                   (poly[middle] if middle >= 0 and middle < len(poly) else None).x)
            dy1 = ((poly[upper] if upper >= 0 and upper < len(poly) else None).y -
                   (poly[middle] if middle >= 0 and middle < len(poly) else None).y)
            cross = ((dx0 * dy1) - ((dx1 * dy0)))
            newIsPositive = (cross > 0)
            if (cross == 0):
                continue
            if (isPositive is None):
                isPositive = newIsPositive
            elif (isPositive != newIsPositive):
                return False
        return True

    @staticmethod
    def isSimple(poly):
        _hx_len = len(poly)
        if (_hx_len <= 3):
            return True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = i
            p1 = (0 if ((i == ((_hx_len - 1)))) else (i + 1))
            _g2 = (i + 1)
            _g11 = _hx_len
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                q0 = j
                q1 = (0 if ((j == ((_hx_len - 1)))) else (j + 1))
                intersection = hxGeomAlgo_PolyTools.segmentIntersect(
                    (poly[p0] if p0 >= 0 and p0 < len(poly) else None),
                    (poly[p1] if p1 >= 0 and p1 < len(poly) else None),
                    (poly[q0] if q0 >= 0 and q0 < len(poly) else None),
                    (poly[q1] if q1 >= 0 and q1 < len(poly) else None))
                tmp = None
                tmp1 = None
                if (intersection is not None):
                    tmp2 = None
                    w = (poly[p0] if p0 >= 0 and p0 < len(poly) else None)
                    x = (intersection.x - w.x)
                    x1 = (intersection.y - w.y)
                    v = ((x * x) + ((x1 * x1)))
                    if (not ((((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))) < hxGeomAlgo_PolyTools.EPSILON))):
                        w1 = (poly[p1] if p1 >= 0 and p1 < len(poly) else None)
                        x2 = (intersection.x - w1.x)
                        x3 = (intersection.y - w1.y)
                        v1 = ((x2 * x2) + ((x3 * x3)))
                        tmp2 = (((Math.NaN if
                                  ((v1 < 0)) else python_lib_Math.sqrt(v1))) < hxGeomAlgo_PolyTools.EPSILON)
                    else:
                        tmp2 = True
                    tmp1 = (not tmp2)
                else:
                    tmp1 = False
                if tmp1:
                    tmp3 = None
                    w2 = (poly[q0] if q0 >= 0 and q0 < len(poly) else None)
                    x4 = (intersection.x - w2.x)
                    x5 = (intersection.y - w2.y)
                    v2 = ((x4 * x4) + ((x5 * x5)))
                    if (not ((((Math.NaN if
                                ((v2 < 0)) else python_lib_Math.sqrt(v2))) < hxGeomAlgo_PolyTools.EPSILON))):
                        w3 = (poly[q1] if q1 >= 0 and q1 < len(poly) else None)
                        x6 = (intersection.x - w3.x)
                        x7 = (intersection.y - w3.y)
                        v3 = ((x6 * x6) + ((x7 * x7)))
                        tmp3 = (((Math.NaN if
                                  ((v3 < 0)) else python_lib_Math.sqrt(v3))) < hxGeomAlgo_PolyTools.EPSILON)
                    else:
                        tmp3 = True
                    tmp = (not tmp3)
                else:
                    tmp = False
                if tmp:
                    return False
        return True

    @staticmethod
    def segmentIntersect(p0, p1, q0, q1):
        a1 = (p1.y - p0.y)
        b1 = (p0.x - p1.x)
        c1 = ((p1.x * p0.y) - ((p0.x * p1.y)))
        a2 = (q1.y - q0.y)
        b2 = (q0.x - q1.x)
        c2 = ((q1.x * q0.y) - ((q0.x * q1.y)))
        denom = ((a1 * b2) - ((a2 * b1)))
        if (denom == 0):
            return None
        intersectionPoint = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
        intersectionPoint.x = ((((b1 * c2) - ((b2 * c1)))) / denom)
        intersectionPoint.y = ((((a2 * c1) - ((a1 * c2)))) / denom)
        x = (p0.x - p1.x)
        x1 = (p0.y - p1.y)
        p0p1 = ((x * x) + ((x1 * x1)))
        x2 = (q0.x - q1.x)
        x3 = (q0.y - q1.y)
        q0q1 = ((x2 * x2) + ((x3 * x3)))
        x4 = (intersectionPoint.x - p1.x)
        x5 = (intersectionPoint.y - p1.y)
        if (((x4 * x4) + ((x5 * x5))) > p0p1):
            return None
        x6 = (intersectionPoint.x - p0.x)
        x7 = (intersectionPoint.y - p0.y)
        if (((x6 * x6) + ((x7 * x7))) > p0p1):
            return None
        x8 = (intersectionPoint.x - q1.x)
        x9 = (intersectionPoint.y - q1.y)
        if (((x8 * x8) + ((x9 * x9))) > q0q1):
            return None
        x10 = (intersectionPoint.x - q0.x)
        x11 = (intersectionPoint.y - q0.y)
        if (((x10 * x10) + ((x11 * x11))) > q0q1):
            return None
        return intersectionPoint

    @staticmethod
    def findDuplicatePoints(poly, consecutiveOnly=None, wrapAround=None):
        if (consecutiveOnly is None):
            consecutiveOnly = True
        if (wrapAround is None):
            wrapAround = True
        _hx_len = len(poly)
        if (_hx_len <= 1):
            return []
        dupIndices = []
        _g = 0
        _g1 = (_hx_len - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            j = (i + 1)
            while (j < _hx_len):
                this1 = (poly[i] if i >= 0 and i < len(poly) else None)
                p = (poly[j] if j >= 0 and j < len(poly) else None)
                foundDup = (((p is not None) and ((this1.x == p.x))) and ((this1.y == p.y)))
                if foundDup:
                    dupIndices.append(i)
                if (consecutiveOnly or ((foundDup and (not consecutiveOnly)))):
                    break
                j = (j + 1)
        tmp = None
        if (wrapAround and consecutiveOnly):
            this2 = (poly[0] if 0 < len(poly) else None)
            p1 = python_internal_ArrayImpl._get(poly, (_hx_len - 1))
            tmp = (((p1 is not None) and ((this2.x == p1.x))) and ((this2.y == p1.y)))
        else:
            tmp = False
        if tmp:
            dupIndices.append((_hx_len - 1))
        return dupIndices

    @staticmethod
    def intersection(p1, p2, q1, q2):
        res = None
        a1 = (p2.y - p1.y)
        b1 = (p1.x - p2.x)
        c1 = ((a1 * p1.x) + ((b1 * p1.y)))
        a2 = (q2.y - q1.y)
        b2 = (q1.x - q2.x)
        c2 = ((a2 * q1.x) + ((b2 * q1.y)))
        det = ((a1 * b2) - ((a2 * b1)))
        if (not ((Reflect.field(Math, "fabs")(det) <= hxGeomAlgo_PolyTools.EPSILON))):
            res = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
            res.x = ((((b2 * c1) - ((b1 * c2)))) / det)
            res.y = ((((a1 * c2) - ((a2 * c1)))) / det)
        return res

    @staticmethod
    def isReflex(poly, idx):
        idx1 = (idx - 1)
        idx2 = idx1
        _hx_len = len(poly)
        if (idx2 < 0):
            idx2 = (idx2 + _hx_len)
        idx1 = HxOverrides.mod(idx2, _hx_len)
        p = (poly[idx1] if idx1 >= 0 and idx1 < len(poly) else None)
        idx3 = idx
        idx4 = idx3
        len1 = len(poly)
        if (idx4 < 0):
            idx4 = (idx4 + len1)
        idx3 = HxOverrides.mod(idx4, len1)
        a = (poly[idx3] if idx3 >= 0 and idx3 < len(poly) else None)
        idx5 = (idx + 1)
        idx6 = idx5
        len2 = len(poly)
        if (idx6 < 0):
            idx6 = (idx6 + len2)
        idx5 = HxOverrides.mod(idx6, len2)
        b = (poly[idx5] if idx5 >= 0 and idx5 < len(poly) else None)
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) < 0)

    @staticmethod
    def at(poly, idx):
        idx1 = idx
        _hx_len = len(poly)
        if (idx1 < 0):
            idx1 = (idx1 + _hx_len)
        idx = HxOverrides.mod(idx1, _hx_len)
        return (poly[idx] if idx >= 0 and idx < len(poly) else None)

    @staticmethod
    def wrappedIdx(poly, idx):
        _hx_len = len(poly)
        if (idx < 0):
            idx = (idx + _hx_len)
        return HxOverrides.mod(idx, _hx_len)

    @staticmethod
    def side(p, a, b):
        return ((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y)))))

    @staticmethod
    def isLeft(p, a, b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) > 0)

    @staticmethod
    def isLeftOrOn(p, a, b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) >= 0)

    @staticmethod
    def isRight(p, a, b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) < 0)

    @staticmethod
    def isRightOrOn(p, a, b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) <= 0)

    @staticmethod
    def isCollinear(p, a, b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) == 0)

    @staticmethod
    def distance(v, w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        v1 = ((x * x) + ((x1 * x1)))
        if (v1 < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v1)

    @staticmethod
    def distanceToSegment(p, v, w):
        v1 = hxGeomAlgo_PolyTools.distanceToSegmentSquared(p, v, w)
        if (v1 < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v1)

    @staticmethod
    def distanceSquared(v, w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        return ((x * x) + ((x1 * x1)))

    @staticmethod
    def distanceToSegmentSquared(p, v, w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        l2 = ((x * x) + ((x1 * x1)))
        if (l2 == 0):
            x2 = (p.x - v.x)
            x3 = (p.y - v.y)
            return ((x2 * x2) + ((x3 * x3)))
        t = ((((((p.x - v.x)) * ((w.x - v.x))) + ((((p.y - v.y)) * ((w.y - v.y)))))) / l2)
        if (t < 0):
            x4 = (p.x - v.x)
            x5 = (p.y - v.y)
            return ((x4 * x4) + ((x5 * x5)))
        if (t > 1):
            x6 = (p.x - w.x)
            x7 = (p.y - w.y)
            return ((x6 * x6) + ((x7 * x7)))
        this1 = hxGeomAlgo_PolyTools.point
        this1.x = (v.x + ((t * ((w.x - v.x)))))
        this1.y = (v.y + ((t * ((w.y - v.y)))))
        w1 = hxGeomAlgo_PolyTools.point
        x8 = (p.x - w1.x)
        x9 = (p.y - w1.y)
        return ((x8 * x8) + ((x9 * x9)))

    @staticmethod
    def getCentroid(poly):
        c = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
        area = hxGeomAlgo_PolyTools.getArea(poly)
        if (area != 0):
            _hx_len = len(poly)
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p0 = (poly[i] if i >= 0 and i < len(poly) else None)
                p1 = python_internal_ArrayImpl._get(poly, HxOverrides.mod(((i + 1)), _hx_len))
                m = ((p0.x * p1.y) - ((p1.x * p0.y)))
                _hx_local_0 = c
                _hx_local_1 = _hx_local_0.x
                _hx_local_0.x = (_hx_local_1 + ((((p0.x + p1.x)) * m)))
                _hx_local_0.x
                _hx_local_2 = c
                _hx_local_3 = _hx_local_2.y
                _hx_local_2.y = (_hx_local_3 + ((((p0.y + p1.y)) * m)))
                _hx_local_2.y
            _hx_local_4 = c
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 / ((6 * area)))
            _hx_local_4.x
            _hx_local_6 = c
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 / ((6 * area)))
            _hx_local_6.y
        else:
            c = hxGeomAlgo__HxPoint_HxPoint_Impl_.EMPTY
        return c

    @staticmethod
    def getArea(poly):
        area = 0.0
        _hx_len = len(poly)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (poly[i] if i >= 0 and i < len(poly) else None)
            p1 = python_internal_ArrayImpl._get(poly, HxOverrides.mod(((i + 1)), _hx_len))
            area = (area + (((p0.x * p1.y) - ((p1.x * p0.y)))))
        area = (.5 * area)
        return area

    @staticmethod
    def meet(p, q):
        return hxGeomAlgo_HomogCoord((p.y - q.y), (q.x - p.x), ((p.x * q.y) - ((p.y * q.x))))

    @staticmethod
    def dot(p, q):
        return ((p.x * q.x) + ((p.y * q.y)))

    @staticmethod
    def sqr(x):
        return (x * x)

    @staticmethod
    def eq(a, b):
        return (Reflect.field(Math, "fabs")((a - b)) <= hxGeomAlgo_PolyTools.EPSILON)

    @staticmethod
    def clear(array):
        array = []

    @staticmethod
    def toFloatArray(poly, out=None):
        out = (out if ((out is not None)) else list())
        _g = 0
        while (_g < len(poly)):
            p = (poly[_g] if _g >= 0 and _g < len(poly) else None)
            _g = (_g + 1)
            x = p.x
            out.append(x)
            x1 = p.y
            out.append(x1)
        return out

    @staticmethod
    def reverseFloatArray(poly, inPlace=None):
        if (inPlace is None):
            inPlace = False
        res = (poly if inPlace else list())
        nPoints = (len(poly) >> 1)
        _g = 0
        _g1 = nPoints
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            xPos = ((((nPoints - i) - 1)) * 2)
            python_internal_ArrayImpl._set(res, (i * 2), (poly[xPos] if xPos >= 0 and xPos < len(poly) else None))
            python_internal_ArrayImpl._set(res, ((i * 2) + 1), python_internal_ArrayImpl._get(poly, (xPos + 1)))
        return res

    @staticmethod
    def flatten(array, out=None):
        res = (out if ((out is not None)) else [])
        _g = 0
        while (_g < len(array)):
            arr = (array[_g] if _g >= 0 and _g < len(array) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(arr)):
                item = (arr[_g1] if _g1 >= 0 and _g1 < len(arr) else None)
                _g1 = (_g1 + 1)
                res.append(item)
        return res

    @staticmethod
    def toPointArray(poly, out=None):
        out = (out if ((out is not None)) else list())
        size = len(poly)
        if (HxOverrides.mod(len(poly), 2) == 1):
            size = (size - 1)
        _g = 0
        _g1 = (size >> 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(python_internal_ArrayImpl._get(poly, (i * 2)),
                                                       python_internal_ArrayImpl._get(poly, ((i * 2) + 1)))
            out.append(x)
        return out

    @staticmethod
    def parsePoints(_hx_str):

        def _hx_local_0(val):
            if (val is not None):
                return (val != "")
            else:
                return False

        floats = list(map(Std.parseFloat, list(filter(_hx_local_0, EReg("[^-eE\\.\\d]+", "g").split(_hx_str)))))
        pts = list()
        n = len(floats)
        _g = 0
        _g1 = None
        try:
            _g1 = int((n / 2))
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            _g1 = None
        _g11 = _g1
        while (_g < _g11):
            i = _g
            _g = (_g + 1)
            x = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(python_internal_ArrayImpl._get(floats, (i * 2)),
                                                       python_internal_ArrayImpl._get(floats, ((i * 2) + 1)))
            pts.append(x)
        return pts

    @staticmethod
    def inflateLine(start, end, thickness):
        halfWidth = (thickness / 2)
        dx = (end.x - start.x)
        dy = (end.y - start.y)
        v = ((dx * dx) + ((dy * dy)))
        _hx_len = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        nx = ((dx / _hx_len) * halfWidth)
        ny = ((dy / _hx_len) * halfWidth)
        return [
            hxGeomAlgo__HxPoint_HxPoint_Impl_._new((start.x - ny), (start.y + nx)),
            hxGeomAlgo__HxPoint_HxPoint_Impl_._new((end.x - ny), (end.y + nx)),
            hxGeomAlgo__HxPoint_HxPoint_Impl_._new((end.x + ny), (end.y - nx)),
            hxGeomAlgo__HxPoint_HxPoint_Impl_._new((start.x + ny), (start.y - nx))
        ]

    @staticmethod
    def clip(subjPoly, clipPoly):
        cond = ((len(clipPoly) >= 3) and hxGeomAlgo_PolyTools.isConvex(clipPoly))
        res = []
        output = subjPoly
        isInside = (hxGeomAlgo_PolyTools.isRight if
                    (hxGeomAlgo_PolyTools.isCCW(clipPoly)) else hxGeomAlgo_PolyTools.isLeft)
        clipEdgeStart = None
        clipEdgeEnd = None
        inputEdgeStart = None
        inputEdgeEnd = None
        clipLen = len(clipPoly)
        _g = 0
        _g1 = clipLen
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            clipEdgeStart = (clipPoly[i] if i >= 0 and i < len(clipPoly) else None)
            idx = (i + 1)
            _hx_len = len(clipPoly)
            if (idx < 0):
                idx = (idx + _hx_len)
            clipEdgeEnd = python_internal_ArrayImpl._get(clipPoly, HxOverrides.mod(idx, _hx_len))
            input = output
            output = []
            inputEdgeStart = python_internal_ArrayImpl._get(input, (len(input) - 1))
            _g2 = 0
            _g11 = len(input)
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                inputEdgeEnd = (input[j] if j >= 0 and j < len(input) else None)
                if isInside(inputEdgeEnd, clipEdgeStart, clipEdgeEnd):
                    if (not isInside(inputEdgeStart, clipEdgeStart, clipEdgeEnd)):
                        intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart, inputEdgeEnd,
                                                                              clipEdgeStart, clipEdgeEnd)
                        if (intersectionPoint is not None):
                            output.append(intersectionPoint)
                    output.append(inputEdgeEnd)
                elif isInside(inputEdgeStart, clipEdgeStart, clipEdgeEnd):
                    intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart, inputEdgeEnd, clipEdgeStart,
                                                                           clipEdgeEnd)
                    if (intersectionPoint1 is not None):
                        output.append(intersectionPoint1)
                inputEdgeStart = inputEdgeEnd
            res.append(output)
        return res

    @staticmethod
    def lerp(a, b, t):
        return ((((1.0 - t)) * a) + ((t * b)))

    @staticmethod
    def lerpPoints(a, b, t):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(((((1.0 - t)) * a.x) + ((t * b.x))),
                                                      ((((1.0 - t)) * a.y) + ((t * b.y))))

    @staticmethod
    def exposeEnum(enumClass, _hx_as=None):
        pass


class hxGeomAlgo_WindingRule(Enum):
    __slots__ = ()
    _hx_class_name = "hxGeomAlgo.WindingRule"


hxGeomAlgo_WindingRule.ODD = hxGeomAlgo_WindingRule("ODD", 0, ())
hxGeomAlgo_WindingRule.NON_ZERO = hxGeomAlgo_WindingRule("NON_ZERO", 1, ())
hxGeomAlgo_WindingRule.POSITIVE = hxGeomAlgo_WindingRule("POSITIVE", 2, ())
hxGeomAlgo_WindingRule.NEGATIVE = hxGeomAlgo_WindingRule("NEGATIVE", 3, ())
hxGeomAlgo_WindingRule.ABS_GEQ_TWO = hxGeomAlgo_WindingRule("ABS_GEQ_TWO", 4, ())


class hxGeomAlgo_ResultType(Enum):
    __slots__ = ()
    _hx_class_name = "hxGeomAlgo.ResultType"


hxGeomAlgo_ResultType.POLYGONS = hxGeomAlgo_ResultType("POLYGONS", 0, ())
hxGeomAlgo_ResultType.CONNECTED_POLYGONS = hxGeomAlgo_ResultType("CONNECTED_POLYGONS", 1, ())
hxGeomAlgo_ResultType.BOUNDARY_CONTOURS = hxGeomAlgo_ResultType("BOUNDARY_CONTOURS", 2, ())
hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY = hxGeomAlgo_ResultType("EXPERIMENTAL_DELAUNAY", 3, ())


class hxGeomAlgo_Tess2:
    _hx_class_name = "hxGeomAlgo.Tess2"
    __slots__ = ()
    _hx_statics = ["tesselate", "union", "intersection", "difference", "convertResult"]

    @staticmethod
    def tesselate(contours, windingRule=None, resultType=None, polySize=None, vertexDim=None, normal=None):
        if (polySize is None):
            polySize = 3
        if (vertexDim is None):
            vertexDim = 2
        tess = hxGeomAlgo_Tesselator()
        _g = 0
        _g1 = len(contours)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tess.addContour(vertexDim, (contours[i] if i >= 0 and i < len(contours) else None))
        tess.tesselate((hxGeomAlgo_WindingRule.ODD if ((windingRule is None)) else windingRule),
                       (hxGeomAlgo_ResultType.POLYGONS if ((resultType is None)) else resultType), polySize, vertexDim,
                       ([0, 0, 1] if ((normal is None)) else normal))
        return _hx_AnonObject({
            'vertices': tess.vertices,
            'vertexIndices': tess.vertexIndices,
            'vertexCount': tess.vertexCount,
            'elements': tess.elements,
            'elementCount': tess.elementCount
        })

    @staticmethod
    def union(contoursA, contoursB, resultType=None, polySize=None, vertexDim=None):
        if (polySize is None):
            polySize = 3
        if (vertexDim is None):
            vertexDim = 2
        contours = (contoursA + contoursB)
        return hxGeomAlgo_Tess2.tesselate(contours, hxGeomAlgo_WindingRule.NON_ZERO, resultType, polySize, vertexDim)

    @staticmethod
    def intersection(contoursA, contoursB, resultType=None, polySize=None, vertexDim=None):
        if (polySize is None):
            polySize = 3
        if (vertexDim is None):
            vertexDim = 2
        contours = (contoursA + contoursB)
        return hxGeomAlgo_Tess2.tesselate(contours, hxGeomAlgo_WindingRule.ABS_GEQ_TWO, resultType, polySize,
                                          vertexDim)

    @staticmethod
    def difference(contoursA, contoursB, resultType=None, polySize=None, vertexDim=None):
        if (polySize is None):
            polySize = 3
        if (vertexDim is None):
            vertexDim = 2
        _g = []
        _g1 = 0
        while (_g1 < len(contoursB)):
            poly = (contoursB[_g1] if _g1 >= 0 and _g1 < len(contoursB) else None)
            _g1 = (_g1 + 1)
            x = hxGeomAlgo_PolyTools.reverseFloatArray(poly)
            _g.append(x)
        diffB = _g
        contours = (contoursA + diffB)
        return hxGeomAlgo_Tess2.tesselate(contours, hxGeomAlgo_WindingRule.POSITIVE, resultType, polySize, vertexDim)

    @staticmethod
    def convertResult(vertices, elements, resultType, polySize, out=None):
        out = (out if ((out is not None)) else list())
        tmp = (resultType.index != 2)
        i = 0
        tmp1 = resultType.index
        if ((tmp1 == 3) or ((tmp1 == 0))):
            while (i < len(elements)):
                poly = []
                _g = 0
                _g1 = polySize
                while (_g < _g1):
                    j = _g
                    _g = (_g + 1)
                    idx = python_internal_ArrayImpl._get(elements, (i + j))
                    if (idx == -1):
                        continue
                    x = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(
                        python_internal_ArrayImpl._get(vertices, (idx * 2)),
                        python_internal_ArrayImpl._get(vertices, ((idx * 2) + 1)))
                    poly.append(x)
                out.append(poly)
                i = (i + polySize)
        elif (tmp1 == 1):
            while (i < len(elements)):
                poly1 = []
                _g2 = 0
                _g11 = polySize
                while (_g2 < _g11):
                    j1 = _g2
                    _g2 = (_g2 + 1)
                    idx1 = python_internal_ArrayImpl._get(elements, (i + j1))
                    if (idx1 == -1):
                        continue
                    x1 = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(
                        python_internal_ArrayImpl._get(vertices, (idx1 * 2)),
                        python_internal_ArrayImpl._get(vertices, ((idx1 * 2) + 1)))
                    poly1.append(x1)
                out.append(poly1)
                i = (i + ((polySize * 2)))
        elif (tmp1 == 2):
            while (i < len(elements)):
                poly2 = []
                start = (elements[i] if i >= 0 and i < len(elements) else None)
                count = python_internal_ArrayImpl._get(elements, (i + 1))
                _g3 = 0
                _g12 = count
                while (_g3 < _g12):
                    j2 = _g3
                    _g3 = (_g3 + 1)
                    idx2 = (start + j2)
                    x2 = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(
                        python_internal_ArrayImpl._get(vertices, (idx2 * 2)),
                        python_internal_ArrayImpl._get(vertices, ((idx2 * 2) + 1)))
                    poly2.append(x2)
                out.append(poly2)
                i = (i + 2)
        else:
            pass
        return out


class hxGeomAlgo__Tess2_TessVertex:
    _hx_class_name = "hxGeomAlgo._Tess2.TessVertex"
    __slots__ = ("next", "prev", "anEdge", "coords", "s", "t", "pqHandle", "n", "idx")
    _hx_fields = ["next", "prev", "anEdge", "coords", "s", "t", "pqHandle", "n", "idx"]

    def __init__(self):
        self.idx = 0
        self.n = 0
        self.pqHandle = 0
        self.t = 0.0
        self.s = 0.0
        self.coords = [0, 0, 0]
        self.anEdge = None
        self.prev = None
        self.next = None


class hxGeomAlgo__Tess2_TessFace:
    _hx_class_name = "hxGeomAlgo._Tess2.TessFace"
    __slots__ = ("next", "prev", "anEdge", "trail", "n", "marked", "inside")
    _hx_fields = ["next", "prev", "anEdge", "trail", "n", "marked", "inside"]

    def __init__(self):
        self.inside = False
        self.marked = False
        self.n = 0
        self.trail = None
        self.anEdge = None
        self.prev = None
        self.next = None


class hxGeomAlgo__Tess2_TessHalfEdge:
    _hx_class_name = "hxGeomAlgo._Tess2.TessHalfEdge"
    __slots__ = ("next", "Sym", "Onext", "Lnext", "Org", "Lface", "activeRegion", "winding", "side", "mark")
    _hx_fields = ["next", "Sym", "Onext", "Lnext", "Org", "Lface", "activeRegion", "winding", "side", "mark"]
    _hx_methods = [
        "get_Rface", "set_Rface", "get_Dst", "set_Dst", "get_Oprev", "set_Oprev", "get_Lprev", "set_Lprev",
        "get_Dprev", "set_Dprev", "get_Rprev", "set_Rprev", "get_Dnext", "set_Dnext", "get_Rnext", "set_Rnext"
    ]

    def __init__(self, side):
        self.mark = None
        self.winding = 0
        self.activeRegion = None
        self.Lface = None
        self.Org = None
        self.Lnext = None
        self.Onext = None
        self.Sym = None
        self.next = None
        self.side = side

    def get_Rface(self):
        return self.Sym.Lface

    def set_Rface(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Lface = v
                return self.Sym.Lface

            return _hx_local_0()

        return _hx_local_1()

    def get_Dst(self):
        return self.Sym.Org

    def set_Dst(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Org = v
                return self.Sym.Org

            return _hx_local_0()

        return _hx_local_1()

    def get_Oprev(self):
        return self.Sym.Lnext

    def set_Oprev(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Lnext = v
                return self.Sym.Lnext

            return _hx_local_0()

        return _hx_local_1()

    def get_Lprev(self):
        return self.Onext.Sym

    def set_Lprev(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Onext.Sym = v
                return self.Onext.Sym

            return _hx_local_0()

        return _hx_local_1()

    def get_Dprev(self):
        return self.Lnext.Sym

    def set_Dprev(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Lnext.Sym = v
                return self.Lnext.Sym

            return _hx_local_0()

        return _hx_local_1()

    def get_Rprev(self):
        return self.Sym.Onext

    def set_Rprev(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Onext = v
                return self.Sym.Onext

            return _hx_local_0()

        return _hx_local_1()

    def get_Dnext(self):
        return self.Sym.Onext.Sym

    def set_Dnext(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Onext.Sym = v
                return self.Sym.Onext.Sym

            return _hx_local_0()

        return _hx_local_1()

    def get_Rnext(self):
        return self.Sym.Lnext.Sym

    def set_Rnext(self, v):

        def _hx_local_1():

            def _hx_local_0():
                self.Sym.Lnext.Sym = v
                return self.Sym.Lnext.Sym

            return _hx_local_0()

        return _hx_local_1()


class hxGeomAlgo__Tess2_TessMesh:
    _hx_class_name = "hxGeomAlgo._Tess2.TessMesh"
    __slots__ = ("v", "f", "e", "eSym", "vHead", "fHead", "eHead", "eHeadSym")
    _hx_fields = ["v", "f", "e", "eSym", "vHead", "fHead", "eHead", "eHeadSym"]
    _hx_methods = [
        "makeEdge_", "splice_", "makeVertex_", "makeFace_", "killEdge_", "killVertex_", "killFace_", "makeEdge",
        "splice", "delete", "addEdgeVertex", "splitEdge", "connect", "zapFace", "countFaceVerts_", "mergeConvexFaces",
        "check"
    ]
    _hx_statics = ["flipEdge"]

    def __init__(self):
        self.eHeadSym = None
        self.eHead = None
        self.fHead = None
        self.vHead = None
        self.eSym = hxGeomAlgo__Tess2_TessHalfEdge(1)
        self.e = hxGeomAlgo__Tess2_TessHalfEdge(0)
        self.f = hxGeomAlgo__Tess2_TessFace()
        self.v = hxGeomAlgo__Tess2_TessVertex()

        def _hx_local_0():
            self.v.prev = self.v
            return self.v.prev

        self.v.next = _hx_local_0()
        self.v.anEdge = None

        def _hx_local_1():
            self.f.prev = self.f
            return self.f.prev

        self.f.next = _hx_local_1()
        self.f.anEdge = None
        self.f.trail = None
        self.f.marked = False
        self.f.inside = False
        self.e.next = self.e
        self.e.Sym = self.eSym
        self.e.Onext = None
        self.e.Lnext = None
        self.e.Org = None
        self.e.Lface = None
        self.e.winding = 0
        self.e.activeRegion = None
        self.e.mark = False
        self.eSym.next = self.eSym
        self.eSym.Sym = self.e
        self.eSym.Onext = None
        self.eSym.Lnext = None
        self.eSym.Org = None
        self.eSym.Lface = None
        self.eSym.winding = 0
        self.eSym.activeRegion = None
        self.e.Sym.mark = False
        self.vHead = self.v
        self.fHead = self.f
        self.eHead = self.e
        self.eHeadSym = self.eSym

    def makeEdge_(self, eNext):
        e = hxGeomAlgo__Tess2_TessHalfEdge(0)
        eSym = hxGeomAlgo__Tess2_TessHalfEdge(1)
        if (eNext.Sym.side < eNext.side):
            eNext = eNext.Sym
        ePrev = eNext.Sym.next
        eSym.next = ePrev
        ePrev.Sym.next = e
        e.next = eNext
        eNext.Sym.next = eSym
        e.Sym = eSym
        e.Onext = e
        e.Lnext = eSym
        e.Org = None
        e.Lface = None
        e.winding = 0
        e.activeRegion = None
        eSym.Sym = e
        eSym.Onext = eSym
        eSym.Lnext = e
        eSym.Org = None
        eSym.Lface = None
        eSym.winding = 0
        eSym.activeRegion = None
        return e

    def splice_(self, a, b):
        aOnext = a.Onext
        bOnext = b.Onext
        aOnext.Sym.Lnext = b
        bOnext.Sym.Lnext = a
        a.Onext = bOnext
        b.Onext = aOnext

    def makeVertex_(self, newVertex, eOrig, vNext):
        vNew = newVertex
        vPrev = vNext.prev
        vNew.prev = vPrev
        vPrev.next = vNew
        vNew.next = vNext
        vNext.prev = vNew
        vNew.anEdge = eOrig
        e = eOrig
        while True:
            e.Org = vNew
            e = e.Onext
            if (not ((e != eOrig))):
                break

    def makeFace_(self, newFace, eOrig, fNext):
        fNew = newFace
        fPrev = fNext.prev
        fNew.prev = fPrev
        fPrev.next = fNew
        fNew.next = fNext
        fNext.prev = fNew
        fNew.anEdge = eOrig
        fNew.trail = None
        fNew.marked = False
        fNew.inside = fNext.inside
        e = eOrig
        while True:
            e.Lface = fNew
            e = e.Lnext
            if (not ((e != eOrig))):
                break

    def killEdge_(self, eDel):
        if (eDel.Sym.side < eDel.side):
            eDel = eDel.Sym
        eNext = eDel.next
        ePrev = eDel.Sym.next
        eNext.Sym.next = ePrev
        ePrev.Sym.next = eNext

    def killVertex_(self, vDel, newOrg):
        eStart = vDel.anEdge
        e = eStart
        while True:
            e.Org = newOrg
            e = e.Onext
            if (not ((e != eStart))):
                break
        vPrev = vDel.prev
        vNext = vDel.next
        vNext.prev = vPrev
        vPrev.next = vNext

    def killFace_(self, fDel, newLface):
        eStart = fDel.anEdge
        e = eStart
        while True:
            e.Lface = newLface
            e = e.Lnext
            if (not ((e != eStart))):
                break
        fPrev = fDel.prev
        fNext = fDel.next
        fNext.prev = fPrev
        fPrev.next = fNext

    def makeEdge(self):
        newVertex1 = hxGeomAlgo__Tess2_TessVertex()
        newVertex2 = hxGeomAlgo__Tess2_TessVertex()
        newFace = hxGeomAlgo__Tess2_TessFace()
        e = self.makeEdge_(self.eHead)
        self.makeVertex_(newVertex1, e, self.vHead)
        self.makeVertex_(newVertex2, e.Sym, self.vHead)
        self.makeFace_(newFace, e, self.fHead)
        return e

    def splice(self, eOrg, eDst):
        joiningLoops = False
        joiningVertices = False
        if (eOrg == eDst):
            return
        if (eDst.Org != eOrg.Org):
            joiningVertices = True
            self.killVertex_(eDst.Org, eOrg.Org)
        if (eDst.Lface != eOrg.Lface):
            joiningLoops = True
            self.killFace_(eDst.Lface, eOrg.Lface)
        self.splice_(eDst, eOrg)
        if (not joiningVertices):
            newVertex = hxGeomAlgo__Tess2_TessVertex()
            self.makeVertex_(newVertex, eDst, eOrg.Org)
            eOrg.Org.anEdge = eOrg
        if (not joiningLoops):
            newFace = hxGeomAlgo__Tess2_TessFace()
            self.makeFace_(newFace, eDst, eOrg.Lface)
            eOrg.Lface.anEdge = eOrg

    def delete(self, eDel):
        eDelSym = eDel.Sym
        joiningLoops = False
        if (eDel.Lface != eDel.get_Rface()):
            joiningLoops = True
            self.killFace_(eDel.Lface, eDel.get_Rface())
        if (eDel.Onext == eDel):
            self.killVertex_(eDel.Org, None)
        else:
            eDel.get_Rface().anEdge = eDel.get_Oprev()
            eDel.Org.anEdge = eDel.Onext
            self.splice_(eDel, eDel.get_Oprev())
            if (not joiningLoops):
                newFace = hxGeomAlgo__Tess2_TessFace()
                self.makeFace_(newFace, eDel, eDel.Lface)
        if (eDelSym.Onext == eDelSym):
            self.killVertex_(eDelSym.Org, None)
            self.killFace_(eDelSym.Lface, None)
        else:
            eDel.Lface.anEdge = eDelSym.get_Oprev()
            eDelSym.Org.anEdge = eDelSym.Onext
            self.splice_(eDelSym, eDelSym.get_Oprev())
        self.killEdge_(eDel)

    def addEdgeVertex(self, eOrg):
        eNew = self.makeEdge_(eOrg)
        eNewSym = eNew.Sym
        self.splice_(eNew, eOrg.Lnext)
        eNew.Org = eOrg.get_Dst()
        newVertex = hxGeomAlgo__Tess2_TessVertex()
        self.makeVertex_(newVertex, eNewSym, eNew.Org)

        def _hx_local_0():
            eNewSym.Lface = eOrg.Lface
            return eNewSym.Lface

        eNew.Lface = _hx_local_0()
        return eNew

    def splitEdge(self, eOrg):
        tempHalfEdge = self.addEdgeVertex(eOrg)
        eNew = tempHalfEdge.Sym
        self.splice_(eOrg.Sym, eOrg.Sym.get_Oprev())
        self.splice_(eOrg.Sym, eNew)
        eOrg.set_Dst(eNew.Org)
        eNew.get_Dst().anEdge = eNew.Sym
        eNew.set_Rface(eOrg.get_Rface())
        eNew.winding = eOrg.winding
        eNew.Sym.winding = eOrg.Sym.winding
        return eNew

    def connect(self, eOrg, eDst):
        joiningLoops = False
        eNew = self.makeEdge_(eOrg)
        eNewSym = eNew.Sym
        if (eDst.Lface != eOrg.Lface):
            joiningLoops = True
            self.killFace_(eDst.Lface, eOrg.Lface)
        self.splice_(eNew, eOrg.Lnext)
        self.splice_(eNewSym, eDst)
        eNew.Org = eOrg.get_Dst()
        eNewSym.Org = eDst.Org

        def _hx_local_0():
            eNewSym.Lface = eOrg.Lface
            return eNewSym.Lface

        eNew.Lface = _hx_local_0()
        eOrg.Lface.anEdge = eNewSym
        if (not joiningLoops):
            newFace = hxGeomAlgo__Tess2_TessFace()
            self.makeFace_(newFace, eNew, eOrg.Lface)
        return eNew

    def zapFace(self, fZap):
        eStart = fZap.anEdge
        e = None
        eSym = None
        eNext = eStart.Lnext
        while True:
            e = eNext
            eNext = e.Lnext
            e.Lface = None
            if (e.get_Rface() is None):
                if (e.Onext == e):
                    self.killVertex_(e.Org, None)
                else:
                    e.Org.anEdge = e.Onext
                    self.splice_(e, e.get_Oprev())
                eSym = e.Sym
                if (eSym.Onext == eSym):
                    self.killVertex_(eSym.Org, None)
                else:
                    eSym.Org.anEdge = eSym.Onext
                    self.splice_(eSym, eSym.get_Oprev())
                self.killEdge_(e)
            if (not ((e != eStart))):
                break
        fPrev = fZap.prev
        fNext = fZap.next
        fNext.prev = fPrev
        fPrev.next = fNext

    def countFaceVerts_(self, f):
        eCur = f.anEdge
        n = 0
        while True:
            n = (n + 1)
            eCur = eCur.Lnext
            if (not ((eCur != f.anEdge))):
                break
        return n

    def mergeConvexFaces(self, maxVertsPerFace):
        eCur = None
        eNext = None
        eSym = None
        vStart = None
        curNv = None
        symNv = None
        f = self.fHead.next
        while (f != self.fHead):
            if (not f.inside):
                f = f.next
                continue
            eCur = f.anEdge
            vStart = eCur.Org
            while True:
                eNext = eCur.Lnext
                eSym = eCur.Sym
                if (((eSym is not None) and ((eSym.Lface is not None))) and eSym.Lface.inside):
                    curNv = self.countFaceVerts_(f)
                    symNv = self.countFaceVerts_(eSym.Lface)
                    if (((curNv + symNv) - 2) <= maxVertsPerFace):
                        if (hxGeomAlgo__Tess2_Geom.vertCCW(eCur.get_Lprev().Org, eCur.Org, eSym.Lnext.Lnext.Org) and
                                hxGeomAlgo__Tess2_Geom.vertCCW(eSym.get_Lprev().Org, eSym.Org, eCur.Lnext.Lnext.Org)):
                            eNext = eSym.Lnext
                            self.delete(eSym)
                            eCur = None
                            eSym = None
                if ((eCur is not None) and ((eCur.Lnext.Org == vStart))):
                    break
                eCur = eNext
            f = f.next
        return True

    def check(self):
        fHead = self.fHead
        vHead = self.vHead
        eHead = self.eHead
        f = None
        v = None
        e = None
        fPrev = fHead
        while True:
            f = fPrev.next
            if (not ((f != fHead))):
                break
            e = f.anEdge
            while True:
                e = e.Lnext
                if (not ((e != f.anEdge))):
                    break
            fPrev = f
        vPrev = vHead
        while True:
            v = vPrev.next
            if (not ((v != vHead))):
                break
            e = v.anEdge
            while True:
                e = e.Onext
                if (not ((e != v.anEdge))):
                    break
            vPrev = v
        ePrev = eHead
        while True:
            e = ePrev.next
            if (not ((e != eHead))):
                break
            cond = (e.get_Dst() is not None)
            ePrev = e
        cond1 = (((((((e.Sym.next == ePrev.Sym) and ((e.Sym == self.eHeadSym))) and ((e.Sym.Sym == e))) and
                    ((e.Org is None))) and ((e.get_Dst() is None))) and ((e.Lface is None))) and
                 ((e.get_Rface() is None)))

    @staticmethod
    def flipEdge(mesh, edge):
        a0 = edge
        a1 = a0.Lnext
        a2 = a1.Lnext
        b0 = edge.Sym
        b1 = b0.Lnext
        b2 = b1.Lnext
        aOrg = a0.Org
        aOpp = a2.Org
        bOrg = b0.Org
        bOpp = b2.Org
        fa = a0.Lface
        fb = b0.Lface
        cond = hxGeomAlgo__Tess2_Geom.edgeIsInternal(edge)
        a0.Org = bOpp
        a0.Onext = b1.Sym
        b0.Org = aOpp
        b0.Onext = a1.Sym
        a2.Onext = b0
        b2.Onext = a0
        b1.Onext = a2.Sym
        a1.Onext = b2.Sym
        a0.Lnext = a2
        a2.Lnext = b1
        b1.Lnext = a0
        b0.Lnext = b2
        b2.Lnext = a1
        a1.Lnext = b0
        a1.Lface = fb
        b1.Lface = fa
        fa.anEdge = a0
        fb.anEdge = b0
        if (aOrg.anEdge == a0):
            aOrg.anEdge = b1
        if (bOrg.anEdge == b0):
            bOrg.anEdge = a1
        cond1 = (a0.get_Oprev().Onext.Org == a0.Org)


class hxGeomAlgo__Tess2_Geom:
    _hx_class_name = "hxGeomAlgo._Tess2.Geom"
    __slots__ = ()
    _hx_statics = [
        "vertEq", "vertLeq", "transLeq", "edgeGoesLeft", "edgeGoesRight", "edgeIsInternal", "vertL1dist", "edgeEval",
        "edgeSign", "transEval", "transSign", "vertCCW", "interpolate", "intersect", "calcAngle",
        "edgeIsLocallyDelaunay"
    ]

    @staticmethod
    def vertEq(u, v):
        if (u.s == v.s):
            return (u.t == v.t)
        else:
            return False

    @staticmethod
    def vertLeq(u, v):
        if (not ((u.s < v.s))):
            if (u.s == v.s):
                return (u.t <= v.t)
            else:
                return False
        else:
            return True

    @staticmethod
    def transLeq(u, v):
        if (not ((u.t < v.t))):
            if (u.t == v.t):
                return (u.s <= v.s)
            else:
                return False
        else:
            return True

    @staticmethod
    def edgeGoesLeft(e):
        return hxGeomAlgo__Tess2_Geom.vertLeq(e.get_Dst(), e.Org)

    @staticmethod
    def edgeGoesRight(e):
        return hxGeomAlgo__Tess2_Geom.vertLeq(e.Org, e.get_Dst())

    @staticmethod
    def edgeIsInternal(e):
        if (e.get_Rface() is not None):
            return e.get_Rface().inside
        else:
            return False

    @staticmethod
    def vertL1dist(u, v):
        return (Reflect.field(Math, "fabs")((u.s - v.s)) + Reflect.field(Math, "fabs")((u.t - v.t)))

    @staticmethod
    def edgeEval(u, v, w):
        cond = (hxGeomAlgo__Tess2_Geom.vertLeq(u, v) and hxGeomAlgo__Tess2_Geom.vertLeq(v, w))
        gapL = (v.s - u.s)
        gapR = (w.s - v.s)
        if ((gapL + gapR) > 0.0):
            if (gapL < gapR):
                return ((v.t - u.t) + ((((u.t - w.t)) * ((gapL / ((gapL + gapR)))))))
            else:
                return ((v.t - w.t) + ((((w.t - u.t)) * ((gapR / ((gapL + gapR)))))))
        return 0.0

    @staticmethod
    def edgeSign(u, v, w):
        cond = (hxGeomAlgo__Tess2_Geom.vertLeq(u, v) and hxGeomAlgo__Tess2_Geom.vertLeq(v, w))
        gapL = (v.s - u.s)
        gapR = (w.s - v.s)
        if ((gapL + gapR) > 0.0):
            return ((((v.t - w.t)) * gapL) + ((((v.t - u.t)) * gapR)))
        return 0.0

    @staticmethod
    def transEval(u, v, w):
        cond = (hxGeomAlgo__Tess2_Geom.transLeq(u, v) and hxGeomAlgo__Tess2_Geom.transLeq(v, w))
        gapL = (v.t - u.t)
        gapR = (w.t - v.t)
        if ((gapL + gapR) > 0.0):
            if (gapL < gapR):
                return ((v.s - u.s) + ((((u.s - w.s)) * ((gapL / ((gapL + gapR)))))))
            else:
                return ((v.s - w.s) + ((((w.s - u.s)) * ((gapR / ((gapL + gapR)))))))
        return 0.0

    @staticmethod
    def transSign(u, v, w):
        cond = (hxGeomAlgo__Tess2_Geom.transLeq(u, v) and hxGeomAlgo__Tess2_Geom.transLeq(v, w))
        gapL = (v.t - u.t)
        gapR = (w.t - v.t)
        if ((gapL + gapR) > 0.0):
            return ((((v.s - w.s)) * gapL) + ((((v.s - u.s)) * gapR)))
        return 0.0

    @staticmethod
    def vertCCW(u, v, w):
        return ((((u.s * ((v.t - w.t))) + ((v.s * ((w.t - u.t))))) + ((w.s * ((u.t - v.t))))) >= 0.0)

    @staticmethod
    def interpolate(a, x, b, y):
        if (a < 0):
            a = 0
        if (b < 0):
            b = 0
        if (a <= b):
            if (b == 0):
                return (((x + y)) / 2)
            else:
                return (x + ((((y - x)) * ((a / ((a + b)))))))
        else:
            return (y + ((((x - y)) * ((b / ((a + b)))))))

    @staticmethod
    def intersect(o1, d1, o2, d2, v):
        z1 = None
        z2 = None
        t = None
        if (not hxGeomAlgo__Tess2_Geom.vertLeq(o1, d1)):
            t = o1
            o1 = d1
            d1 = t
        if (not hxGeomAlgo__Tess2_Geom.vertLeq(o2, d2)):
            t = o2
            o2 = d2
            d2 = t
        if (not hxGeomAlgo__Tess2_Geom.vertLeq(o1, o2)):
            t = o1
            o1 = o2
            o2 = t
            t = d1
            d1 = d2
            d2 = t
        if (not hxGeomAlgo__Tess2_Geom.vertLeq(o2, d1)):
            v.s = (((o2.s + d1.s)) / 2)
        elif hxGeomAlgo__Tess2_Geom.vertLeq(d1, d2):
            z1 = hxGeomAlgo__Tess2_Geom.edgeEval(o1, o2, d1)
            z2 = hxGeomAlgo__Tess2_Geom.edgeEval(o2, d1, d2)
            if ((z1 + z2) < 0):
                z1 = -z1
                z2 = -z2
            v.s = hxGeomAlgo__Tess2_Geom.interpolate(z1, o2.s, z2, d1.s)
        else:
            z1 = hxGeomAlgo__Tess2_Geom.edgeSign(o1, o2, d1)
            z2 = -hxGeomAlgo__Tess2_Geom.edgeSign(o1, d2, d1)
            if ((z1 + z2) < 0):
                z1 = -z1
                z2 = -z2
            v.s = hxGeomAlgo__Tess2_Geom.interpolate(z1, o2.s, z2, d2.s)
        if (not hxGeomAlgo__Tess2_Geom.transLeq(o1, d1)):
            t = o1
            o1 = d1
            d1 = t
        if (not hxGeomAlgo__Tess2_Geom.transLeq(o2, d2)):
            t = o2
            o2 = d2
            d2 = t
        if (not hxGeomAlgo__Tess2_Geom.transLeq(o1, o2)):
            t = o1
            o1 = o2
            o2 = t
            t = d1
            d1 = d2
            d2 = t
        if (not hxGeomAlgo__Tess2_Geom.transLeq(o2, d1)):
            v.t = (((o2.t + d1.t)) / 2)
        elif hxGeomAlgo__Tess2_Geom.transLeq(d1, d2):
            z1 = hxGeomAlgo__Tess2_Geom.transEval(o1, o2, d1)
            z2 = hxGeomAlgo__Tess2_Geom.transEval(o2, d1, d2)
            if ((z1 + z2) < 0):
                z1 = -z1
                z2 = -z2
            v.t = hxGeomAlgo__Tess2_Geom.interpolate(z1, o2.t, z2, d1.t)
        else:
            z1 = hxGeomAlgo__Tess2_Geom.transSign(o1, o2, d1)
            z2 = -hxGeomAlgo__Tess2_Geom.transSign(o1, d2, d1)
            if ((z1 + z2) < 0):
                z1 = -z1
                z2 = -z2
            v.t = hxGeomAlgo__Tess2_Geom.interpolate(z1, o2.t, z2, d2.t)

    @staticmethod
    def calcAngle(v0, v1, v2):
        a_0 = (v2.s - v1.s)
        a_1 = (v2.t - v1.t)
        b_0 = (v0.s - v1.s)
        b_1 = (v0.t - v1.t)
        num = ((a_0 * b_0) + ((a_1 * b_1)))
        v = ((a_0 * a_0) + ((a_1 * a_1)))
        v3 = ((b_0 * b_0) + ((b_1 * b_1)))
        den = (((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))) * ((Math.NaN if
                                                                          ((v3 < 0)) else python_lib_Math.sqrt(v3))))
        if (den > 0.0):
            num = (num / den)
        if (num < -1.0):
            num = -1.0
        if (num > 1.0):
            num = 1.0
        return Math.acos(num)

    @staticmethod
    def edgeIsLocallyDelaunay(e):
        return ((hxGeomAlgo__Tess2_Geom.calcAngle(e.Lnext.Org, e.Lnext.Lnext.Org, e.Org) +
                 hxGeomAlgo__Tess2_Geom.calcAngle(e.Sym.Lnext.Org, e.Sym.Lnext.Lnext.Org, e.Sym.Org)) <
                ((Math.PI + 0.01)))


class hxGeomAlgo__Tess2_DictNode:
    _hx_class_name = "hxGeomAlgo._Tess2.DictNode"
    __slots__ = ("key", "next", "prev")
    _hx_fields = ["key", "next", "prev"]

    def __init__(self):
        self.prev = None
        self.next = None
        self.key = None


class hxGeomAlgo__Tess2_Dict:
    _hx_class_name = "hxGeomAlgo._Tess2.Dict"
    __slots__ = ("head", "frame", "leq")
    _hx_fields = ["head", "frame", "leq"]
    _hx_methods = ["min", "max", "insert", "search", "insertBefore", "delete"]

    def __init__(self, frame, leq):
        self.leq = None
        self.frame = None
        self.head = hxGeomAlgo__Tess2_DictNode()
        self.head.next = self.head
        self.head.prev = self.head
        self.frame = frame
        self.leq = leq

    def min(self):
        return self.head.next

    def max(self):
        return self.head.prev

    def insert(self, k):
        return self.insertBefore(self.head, k)

    def search(self, key):
        node = self.head
        while True:
            node = node.next
            if (not (((node.key is not None) and (not self.leq(self.frame, key, node.key))))):
                break
        return node

    def insertBefore(self, node, key):
        while True:
            node = node.prev
            if (not (((node.key is not None) and (not self.leq(self.frame, node.key, key))))):
                break
        newNode = hxGeomAlgo__Tess2_DictNode()
        newNode.key = key
        newNode.next = node.next
        node.next.prev = newNode
        newNode.prev = node
        node.next = newNode
        return newNode

    def delete(self, node):
        node.next.prev = node.prev
        node.prev.next = node.next


class hxGeomAlgo__Tess2_PQNode:
    _hx_class_name = "hxGeomAlgo._Tess2.PQNode"
    __slots__ = ("handle",)
    _hx_fields = ["handle"]

    def __init__(self):
        self.handle = -1


class hxGeomAlgo__Tess2_PQHandleElem:
    _hx_class_name = "hxGeomAlgo._Tess2.PQHandleElem"
    __slots__ = ("key", "node")
    _hx_fields = ["key", "node"]

    def __init__(self):
        self.node = -1
        self.key = None


class hxGeomAlgo__Tess2_PriorityQ:
    _hx_class_name = "hxGeomAlgo._Tess2.PriorityQ"
    __slots__ = ("size", "max", "nodes", "handles", "initialized", "freeList", "leq")
    _hx_fields = ["size", "max", "nodes", "handles", "initialized", "freeList", "leq"]
    _hx_methods = ["floatDown_", "floatUp_", "init", "min", "isEmpty", "insert", "extractMin", "delete"]

    def __init__(self, size, leq):
        self.size = 0
        self.max = size
        self.nodes = []
        _g = 0
        _g1 = (size + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.nodes, i, hxGeomAlgo__Tess2_PQNode())
        self.handles = []
        _g2 = 0
        _g3 = (size + 1)
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            python_internal_ArrayImpl._set(self.handles, i1, hxGeomAlgo__Tess2_PQHandleElem())
        self.initialized = False
        self.freeList = 0
        self.leq = leq
        (self.nodes[1] if 1 < len(self.nodes) else None).handle = 1
        (self.handles[1] if 1 < len(self.handles) else None).key = None

    def floatDown_(self, curr):
        n = self.nodes
        h = self.handles
        hChild = None
        child = None
        hCurr = (n[curr] if curr >= 0 and curr < len(n) else None).handle
        while True:
            child = (curr << 1)
            if ((child < self.size) and self.leq(
                    python_internal_ArrayImpl._get(h,
                                                   python_internal_ArrayImpl._get(n, (child + 1)).handle).key,
                    python_internal_ArrayImpl._get(h,
                                                   (n[child] if child >= 0 and child < len(n) else None).handle).key)):
                child = (child + 1)
            hChild = (n[child] if child >= 0 and child < len(n) else None).handle
            if ((child > self.size) or self.leq((h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).key,
                                                (h[hChild] if hChild >= 0 and hChild < len(h) else None).key)):
                (n[curr] if curr >= 0 and curr < len(n) else None).handle = hCurr
                (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).node = curr
                break
            (n[curr] if curr >= 0 and curr < len(n) else None).handle = hChild
            (h[hChild] if hChild >= 0 and hChild < len(h) else None).node = curr
            curr = child

    def floatUp_(self, curr):
        n = self.nodes
        h = self.handles
        hParent = None
        parent = None
        hCurr = (n[curr] if curr >= 0 and curr < len(n) else None).handle
        while True:
            parent = (curr >> 1)
            hParent = (n[parent] if parent >= 0 and parent < len(n) else None).handle
            if ((parent == 0) or self.leq((h[hParent] if hParent >= 0 and hParent < len(h) else None).key,
                                          (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).key)):
                (n[curr] if curr >= 0 and curr < len(n) else None).handle = hCurr
                (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).node = curr
                break
            (n[curr] if curr >= 0 and curr < len(n) else None).handle = hParent
            (h[hParent] if hParent >= 0 and hParent < len(h) else None).node = curr
            curr = parent

    def init(self):
        i = self.size
        while (i >= 1):
            self.floatDown_(i)
            i = (i - 1)
        self.initialized = True

    def min(self):
        return python_internal_ArrayImpl._get(self.handles,
                                              (self.nodes[1] if 1 < len(self.nodes) else None).handle).key

    def isEmpty(self):
        return (self.size == 0)

    def insert(self, keyNew):
        free = None
        self.size = (self.size + 1)
        curr = self.size
        if ((curr * 2) > self.max):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.max
            _hx_local_0.max = (_hx_local_1 * 2)
            _hx_local_0.max
            s = len(self.nodes)
            _g = s
            _g1 = (self.max + 1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._set(self.nodes, i, hxGeomAlgo__Tess2_PQNode())
            s = len(self.handles)
            _g2 = len(self.handles)
            _g3 = (self.max + 1)
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                python_internal_ArrayImpl._set(self.handles, i1, hxGeomAlgo__Tess2_PQHandleElem())
        if (self.freeList == 0):
            free = curr
        else:
            free = self.freeList
            self.freeList = (self.handles[free] if free >= 0 and free < len(self.handles) else None).node
        (self.nodes[curr] if curr >= 0 and curr < len(self.nodes) else None).handle = free
        (self.handles[free] if free >= 0 and free < len(self.handles) else None).node = curr
        (self.handles[free] if free >= 0 and free < len(self.handles) else None).key = keyNew
        if self.initialized:
            self.floatUp_(curr)
        return free

    def extractMin(self):
        n = self.nodes
        h = self.handles
        hMin = (n[1] if 1 < len(n) else None).handle
        _hx_min = (h[hMin] if hMin >= 0 and hMin < len(h) else None).key
        if (self.size > 0):
            (n[1] if 1 < len(n) else None).handle = python_internal_ArrayImpl._get(n, self.size).handle
            python_internal_ArrayImpl._get(h, (n[1] if 1 < len(n) else None).handle).node = 1
            (h[hMin] if hMin >= 0 and hMin < len(h) else None).key = None
            (h[hMin] if hMin >= 0 and hMin < len(h) else None).node = self.freeList
            self.freeList = hMin
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.size
            _hx_local_0.size = (_hx_local_1 - 1)
            _hx_local_0.size
            if (self.size > 0):
                self.floatDown_(1)
        return _hx_min

    def delete(self, hCurr):
        n = self.nodes
        h = self.handles
        curr = (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).node
        (n[curr] if curr >= 0 and curr < len(n) else None).handle = python_internal_ArrayImpl._get(n, self.size).handle
        python_internal_ArrayImpl._get(h, (n[curr] if curr >= 0 and curr < len(n) else None).handle).node = curr
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.size
        _hx_local_0.size = (_hx_local_1 - 1)
        _hx_local_0.size
        if (curr <= self.size):
            if ((curr <= 1) or self.leq(
                    python_internal_ArrayImpl._get(h,
                                                   python_internal_ArrayImpl._get(n, (curr >> 1)).handle).key,
                    python_internal_ArrayImpl._get(h, (n[curr] if curr >= 0 and curr < len(n) else None).handle).key)):
                self.floatDown_(curr)
            else:
                self.floatUp_(curr)
        (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).key = None
        (h[hCurr] if hCurr >= 0 and hCurr < len(h) else None).node = self.freeList
        self.freeList = hCurr


class hxGeomAlgo__Tess2_ActiveRegion:
    _hx_class_name = "hxGeomAlgo._Tess2.ActiveRegion"
    __slots__ = ("eUp", "nodeUp", "windingNumber", "inside", "sentinel", "dirty", "fixUpperEdge")
    _hx_fields = ["eUp", "nodeUp", "windingNumber", "inside", "sentinel", "dirty", "fixUpperEdge"]

    def __init__(self):
        self.fixUpperEdge = False
        self.dirty = False
        self.sentinel = False
        self.inside = False
        self.windingNumber = 0
        self.nodeUp = None
        self.eUp = None


class hxGeomAlgo__Tess2_Sweep:
    _hx_class_name = "hxGeomAlgo._Tess2.Sweep"
    __slots__ = ()
    _hx_statics = [
        "regionBelow", "regionAbove", "debugEvent", "addWinding", "edgeLeq", "deleteRegion", "fixUpperEdge",
        "topLeftRegion", "topRightRegion", "addRegionBelow", "isWindingInside", "computeWinding", "finishRegion",
        "finishLeftRegions", "addRightEdges", "spliceMergeVertices", "vertexWeights", "getIntersectData",
        "checkForRightSplice", "checkForLeftSplice", "checkForIntersect", "walkDirtyRegions", "connectRightVertex",
        "connectLeftDegenerate", "connectLeftVertex", "sweepEvent", "addSentinel", "initEdgeDict", "doneEdgeDict",
        "removeDegenerateEdges", "initPriorityQ", "donePriorityQ", "removeDegenerateFaces", "computeInterior"
    ]

    @staticmethod
    def regionBelow(r):
        return r.nodeUp.prev.key

    @staticmethod
    def regionAbove(r):
        return r.nodeUp.next.key

    @staticmethod
    def debugEvent(tess):
        pass

    @staticmethod
    def addWinding(eDst, eSrc):
        eDst.winding = (eDst.winding + eSrc.winding)
        _hx_local_1 = eDst.Sym
        _hx_local_2 = _hx_local_1.winding
        _hx_local_1.winding = (_hx_local_2 + eSrc.Sym.winding)
        _hx_local_1.winding

    @staticmethod
    def edgeLeq(tess, reg1, reg2):
        ev = tess.event
        t1 = None
        t2 = None
        e1 = reg1.eUp
        e2 = reg2.eUp
        if (e1.get_Dst() == ev):
            if (e2.get_Dst() == ev):
                if hxGeomAlgo__Tess2_Geom.vertLeq(e1.Org, e2.Org):
                    return (hxGeomAlgo__Tess2_Geom.edgeSign(e2.get_Dst(), e1.Org, e2.Org) <= 0)
                return (hxGeomAlgo__Tess2_Geom.edgeSign(e1.get_Dst(), e2.Org, e1.Org) >= 0)
            return (hxGeomAlgo__Tess2_Geom.edgeSign(e2.get_Dst(), ev, e2.Org) <= 0)
        if (e2.get_Dst() == ev):
            return (hxGeomAlgo__Tess2_Geom.edgeSign(e1.get_Dst(), ev, e1.Org) >= 0)
        t11 = hxGeomAlgo__Tess2_Geom.edgeEval(e1.get_Dst(), ev, e1.Org)
        t21 = hxGeomAlgo__Tess2_Geom.edgeEval(e2.get_Dst(), ev, e2.Org)
        return (t11 >= t21)

    @staticmethod
    def deleteRegion(tess, reg):
        reg1 = reg.fixUpperEdge
        reg.eUp.activeRegion = None
        tess.dict.delete(reg.nodeUp)

    @staticmethod
    def fixUpperEdge(tess, reg, newEdge):
        tess.mesh.delete(reg.eUp)
        reg.fixUpperEdge = False
        reg.eUp = newEdge
        newEdge.activeRegion = reg

    @staticmethod
    def topLeftRegion(tess, reg):
        org = reg.eUp.Org
        e = None
        while True:
            reg = hxGeomAlgo__Tess2_Sweep.regionAbove(reg)
            if (not ((reg.eUp.Org == org))):
                break
        if reg.fixUpperEdge:
            e = tess.mesh.connect(hxGeomAlgo__Tess2_Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext)
            if (e is None):
                return None
            hxGeomAlgo__Tess2_Sweep.fixUpperEdge(tess, reg, e)
            reg = hxGeomAlgo__Tess2_Sweep.regionAbove(reg)
        return reg

    @staticmethod
    def topRightRegion(reg):
        dst = reg.eUp.get_Dst()
        while True:
            reg = hxGeomAlgo__Tess2_Sweep.regionAbove(reg)
            if (not ((reg.eUp.get_Dst() == dst))):
                break
        return reg

    @staticmethod
    def addRegionBelow(tess, regAbove, eNewUp):
        regNew = hxGeomAlgo__Tess2_ActiveRegion()
        regNew.eUp = eNewUp
        regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew)
        regNew.fixUpperEdge = False
        regNew.sentinel = False
        regNew.dirty = False
        eNewUp.activeRegion = regNew
        return regNew

    @staticmethod
    def isWindingInside(tess, n):
        tmp = tess.windingRule.index
        if (tmp == 0):
            return (((n & 1)) != 0)
        elif (tmp == 1):
            return (n != 0)
        elif (tmp == 2):
            return (n > 0)
        elif (tmp == 3):
            return (n < 0)
        elif (tmp == 4):
            if (n < 2):
                return (n <= -2)
            else:
                return True
        else:
            pass

    @staticmethod
    def computeWinding(tess, reg):
        reg.windingNumber = (hxGeomAlgo__Tess2_Sweep.regionAbove(reg).windingNumber + reg.eUp.winding)
        reg.inside = hxGeomAlgo__Tess2_Sweep.isWindingInside(tess, reg.windingNumber)

    @staticmethod
    def finishRegion(tess, reg):
        e = reg.eUp
        f = e.Lface
        f.inside = reg.inside
        f.anEdge = e
        hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, reg)

    @staticmethod
    def finishLeftRegions(tess, regFirst, regLast):
        e = None
        ePrev = None
        reg = None
        regPrev = regFirst
        ePrev1 = regFirst.eUp
        while (regPrev != regLast):
            regPrev.fixUpperEdge = False
            reg = hxGeomAlgo__Tess2_Sweep.regionBelow(regPrev)
            e = reg.eUp
            if (e.Org != ePrev1.Org):
                if (not reg.fixUpperEdge):
                    hxGeomAlgo__Tess2_Sweep.finishRegion(tess, regPrev)
                    break
                e = tess.mesh.connect(ePrev1.get_Lprev(), e.Sym)
                hxGeomAlgo__Tess2_Sweep.fixUpperEdge(tess, reg, e)
            if (ePrev1.Onext != e):
                tess.mesh.splice(e.get_Oprev(), e)
                tess.mesh.splice(ePrev1, e)
            hxGeomAlgo__Tess2_Sweep.finishRegion(tess, regPrev)
            ePrev1 = reg.eUp
            regPrev = reg
        return ePrev1

    @staticmethod
    def addRightEdges(tess, regUp, eFirst, eLast, eTopLeft, cleanUp):
        reg = None
        firstTime = True
        e = eFirst
        while True:
            cond = hxGeomAlgo__Tess2_Geom.vertLeq(e.Org, e.get_Dst())
            hxGeomAlgo__Tess2_Sweep.addRegionBelow(tess, regUp, e.Sym)
            e = e.Onext
            if (not ((e != eLast))):
                break
        if (eTopLeft is None):
            eTopLeft = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev()
        regPrev = regUp
        ePrev = eTopLeft
        while True:
            reg = hxGeomAlgo__Tess2_Sweep.regionBelow(regPrev)
            e = reg.eUp.Sym
            if (e.Org != ePrev.Org):
                break
            if (e.Onext != ePrev):
                tess.mesh.splice(e.get_Oprev(), e)
                tess.mesh.splice(ePrev.get_Oprev(), e)
            reg.windingNumber = (regPrev.windingNumber - e.winding)
            reg.inside = hxGeomAlgo__Tess2_Sweep.isWindingInside(tess, reg.windingNumber)
            regPrev.dirty = True
            if ((not firstTime) and hxGeomAlgo__Tess2_Sweep.checkForRightSplice(tess, regPrev)):
                hxGeomAlgo__Tess2_Sweep.addWinding(e, ePrev)
                hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, regPrev)
                tess.mesh.delete(ePrev)
            firstTime = False
            regPrev = reg
            ePrev = e
        regPrev.dirty = True
        if cleanUp:
            hxGeomAlgo__Tess2_Sweep.walkDirtyRegions(tess, regPrev)

    @staticmethod
    def spliceMergeVertices(tess, e1, e2):
        tess.mesh.splice(e1, e2)

    @staticmethod
    def vertexWeights(isect, org, dst):
        t1 = hxGeomAlgo__Tess2_Geom.vertL1dist(org, isect)
        t2 = hxGeomAlgo__Tess2_Geom.vertL1dist(dst, isect)
        w0 = ((0.5 * t2) / ((t1 + t2)))
        w1 = ((0.5 * t1) / ((t1 + t2)))
        _hx_local_0 = isect.coords
        _hx_local_1 = 0
        _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1,
                                       (_hx_local_2 + (((w0 * (org.coords[0] if 0 < len(org.coords) else None)) +
                                                        ((w1 * (dst.coords[0] if 0 < len(dst.coords) else None)))))))
        (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        _hx_local_3 = isect.coords
        _hx_local_4 = 1
        _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4,
                                       (_hx_local_5 + (((w0 * (org.coords[1] if 1 < len(org.coords) else None)) +
                                                        ((w1 * (dst.coords[1] if 1 < len(dst.coords) else None)))))))
        (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        _hx_local_6 = isect.coords
        _hx_local_7 = 2
        _hx_local_8 = (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
        python_internal_ArrayImpl._set(_hx_local_6, _hx_local_7,
                                       (_hx_local_8 + (((w0 * (org.coords[2] if 2 < len(org.coords) else None)) +
                                                        ((w1 * (dst.coords[2] if 2 < len(dst.coords) else None)))))))
        (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)

    @staticmethod
    def getIntersectData(tess, isect, orgUp, dstUp, orgLo, dstLo):

        def _hx_local_1():

            def _hx_local_0():
                python_internal_ArrayImpl._set(isect.coords, 2, 0)
                return (isect.coords[2] if 2 < len(isect.coords) else None)

            python_internal_ArrayImpl._set(isect.coords, 1, _hx_local_0())
            return (isect.coords[1] if 1 < len(isect.coords) else None)

        tmp = _hx_local_1()
        python_internal_ArrayImpl._set(isect.coords, 0, tmp)
        isect.idx = -1
        hxGeomAlgo__Tess2_Sweep.vertexWeights(isect, orgUp, dstUp)
        hxGeomAlgo__Tess2_Sweep.vertexWeights(isect, orgLo, dstLo)

    @staticmethod
    def checkForRightSplice(tess, regUp):
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eUp = regUp.eUp
        eLo = regLo.eUp
        if hxGeomAlgo__Tess2_Geom.vertLeq(eUp.Org, eLo.Org):
            if (hxGeomAlgo__Tess2_Geom.edgeSign(eLo.get_Dst(), eUp.Org, eLo.Org) > 0):
                return False
            if (not hxGeomAlgo__Tess2_Geom.vertEq(eUp.Org, eLo.Org)):
                tess.mesh.splitEdge(eLo.Sym)
                tess.mesh.splice(eUp, eLo.get_Oprev())

                def _hx_local_0():
                    regLo.dirty = True
                    return regLo.dirty

                regUp.dirty = _hx_local_0()
            elif (eUp.Org != eLo.Org):
                tess.pq.delete(eUp.Org.pqHandle)
                hxGeomAlgo__Tess2_Sweep.spliceMergeVertices(tess, eLo.get_Oprev(), eUp)
        else:
            if (hxGeomAlgo__Tess2_Geom.edgeSign(eUp.get_Dst(), eLo.Org, eUp.Org) < 0):
                return False

            def _hx_local_1():
                regUp.dirty = True
                return regUp.dirty

            hxGeomAlgo__Tess2_Sweep.regionAbove(regUp).dirty = _hx_local_1()
            tess.mesh.splitEdge(eUp.Sym)
            tess.mesh.splice(eLo.get_Oprev(), eUp)
        return True

    @staticmethod
    def checkForLeftSplice(tess, regUp):
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eUp = regUp.eUp
        eLo = regLo.eUp
        e = None
        cond = (not hxGeomAlgo__Tess2_Geom.vertEq(eUp.get_Dst(), eLo.get_Dst()))
        if hxGeomAlgo__Tess2_Geom.vertLeq(eUp.get_Dst(), eLo.get_Dst()):
            if (hxGeomAlgo__Tess2_Geom.edgeSign(eUp.get_Dst(), eLo.get_Dst(), eUp.Org) < 0):
                return False

            def _hx_local_0():
                regUp.dirty = True
                return regUp.dirty

            hxGeomAlgo__Tess2_Sweep.regionAbove(regUp).dirty = _hx_local_0()
            e = tess.mesh.splitEdge(eUp)
            tess.mesh.splice(eLo.Sym, e)
            e.Lface.inside = regUp.inside
        else:
            if (hxGeomAlgo__Tess2_Geom.edgeSign(eLo.get_Dst(), eUp.get_Dst(), eLo.Org) > 0):
                return False

            def _hx_local_1():
                regLo.dirty = True
                return regLo.dirty

            regUp.dirty = _hx_local_1()
            e = tess.mesh.splitEdge(eLo)
            tess.mesh.splice(eUp.Lnext, eLo.Sym)
            e.get_Rface().inside = regUp.inside
        return True

    @staticmethod
    def checkForIntersect(tess, regUp):
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eUp = regUp.eUp
        eLo = regLo.eUp
        orgUp = eUp.Org
        orgLo = eLo.Org
        dstUp = eUp.get_Dst()
        dstLo = eLo.get_Dst()
        isect = hxGeomAlgo__Tess2_TessVertex()
        e = None
        cond = (not hxGeomAlgo__Tess2_Geom.vertEq(dstLo, dstUp))
        cond1 = (hxGeomAlgo__Tess2_Geom.edgeSign(dstUp, tess.event, orgUp) <= 0)
        cond2 = (hxGeomAlgo__Tess2_Geom.edgeSign(dstLo, tess.event, orgLo) >= 0)
        if (orgUp == orgLo):
            return False
        a = orgUp.t
        b = dstUp.t
        tMinUp = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a, b)))
        a1 = orgLo.t
        b1 = dstLo.t
        tMaxLo = (a1 if (python_lib_Math.isnan(a1)) else (b1 if (python_lib_Math.isnan(b1)) else max(a1, b1)))
        if (tMinUp > tMaxLo):
            return False
        if hxGeomAlgo__Tess2_Geom.vertLeq(orgUp, orgLo):
            if (hxGeomAlgo__Tess2_Geom.edgeSign(dstLo, orgUp, orgLo) > 0):
                return False
        elif (hxGeomAlgo__Tess2_Geom.edgeSign(dstUp, orgLo, orgUp) < 0):
            return False
        hxGeomAlgo__Tess2_Sweep.debugEvent(tess)
        hxGeomAlgo__Tess2_Geom.intersect(dstUp, orgUp, dstLo, orgLo, isect)
        a2 = orgUp.t
        b2 = dstUp.t
        cond3 = (((a2 if (python_lib_Math.isnan(a2)) else (b2 if
                                                           (python_lib_Math.isnan(b2)) else min(a2, b2)))) <= isect.t)
        a3 = orgLo.t
        b3 = dstLo.t
        cond4 = (isect.t <= ((a3 if (python_lib_Math.isnan(a3)) else (b3 if
                                                                      (python_lib_Math.isnan(b3)) else max(a3, b3)))))
        a4 = dstLo.s
        b4 = dstUp.s
        cond5 = (((a4 if (python_lib_Math.isnan(a4)) else (b4 if
                                                           (python_lib_Math.isnan(b4)) else min(a4, b4)))) <= isect.s)
        a5 = orgLo.s
        b5 = orgUp.s
        cond6 = (isect.s <= ((a5 if (python_lib_Math.isnan(a5)) else (b5 if
                                                                      (python_lib_Math.isnan(b5)) else max(a5, b5)))))
        if hxGeomAlgo__Tess2_Geom.vertLeq(isect, tess.event):
            isect.s = tess.event.s
            isect.t = tess.event.t
        orgMin = (orgUp if (hxGeomAlgo__Tess2_Geom.vertLeq(orgUp, orgLo)) else orgLo)
        if hxGeomAlgo__Tess2_Geom.vertLeq(orgMin, isect):
            isect.s = orgMin.s
            isect.t = orgMin.t
        if (hxGeomAlgo__Tess2_Geom.vertEq(isect, orgUp) or hxGeomAlgo__Tess2_Geom.vertEq(isect, orgLo)):
            hxGeomAlgo__Tess2_Sweep.checkForRightSplice(tess, regUp)
            return False
        if (((not hxGeomAlgo__Tess2_Geom.vertEq(dstUp, tess.event)) and
             ((hxGeomAlgo__Tess2_Geom.edgeSign(dstUp, tess.event, isect) >= 0))) or
            (((not hxGeomAlgo__Tess2_Geom.vertEq(dstLo, tess.event)) and
              ((hxGeomAlgo__Tess2_Geom.edgeSign(dstLo, tess.event, isect) <= 0))))):
            if (dstLo == tess.event):
                tess.mesh.splitEdge(eUp.Sym)
                tess.mesh.splice(eLo.Sym, eUp)
                regUp = hxGeomAlgo__Tess2_Sweep.topLeftRegion(tess, regUp)
                eUp = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp).eUp
                hxGeomAlgo__Tess2_Sweep.finishLeftRegions(tess, hxGeomAlgo__Tess2_Sweep.regionBelow(regUp), regLo)
                hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eUp.get_Oprev(), eUp, eUp, True)
                return True
            if (dstUp == tess.event):
                tess.mesh.splitEdge(eLo.Sym)
                tess.mesh.splice(eUp.Lnext, eLo.get_Oprev())
                regLo = regUp
                regUp = hxGeomAlgo__Tess2_Sweep.topRightRegion(regUp)
                e = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev()
                regLo.eUp = eLo.get_Oprev()
                eLo = hxGeomAlgo__Tess2_Sweep.finishLeftRegions(tess, regLo, None)
                hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eLo.Onext, eUp.get_Rprev(), e, True)
                return True
            if (hxGeomAlgo__Tess2_Geom.edgeSign(dstUp, tess.event, isect) >= 0):

                def _hx_local_0():
                    regUp.dirty = True
                    return regUp.dirty

                hxGeomAlgo__Tess2_Sweep.regionAbove(regUp).dirty = _hx_local_0()
                tess.mesh.splitEdge(eUp.Sym)
                eUp.Org.s = tess.event.s
                eUp.Org.t = tess.event.t
            if (hxGeomAlgo__Tess2_Geom.edgeSign(dstLo, tess.event, isect) <= 0):

                def _hx_local_1():
                    regLo.dirty = True
                    return regLo.dirty

                regUp.dirty = _hx_local_1()
                tess.mesh.splitEdge(eLo.Sym)
                eLo.Org.s = tess.event.s
                eLo.Org.t = tess.event.t
            return False
        tess.mesh.splitEdge(eUp.Sym)
        tess.mesh.splitEdge(eLo.Sym)
        tess.mesh.splice(eLo.get_Oprev(), eUp)
        eUp.Org.s = isect.s
        eUp.Org.t = isect.t
        eUp.Org.pqHandle = tess.pq.insert(eUp.Org)
        hxGeomAlgo__Tess2_Sweep.getIntersectData(tess, eUp.Org, orgUp, dstUp, orgLo, dstLo)

        def _hx_local_3():

            def _hx_local_2():
                regLo.dirty = True
                return regLo.dirty

            regUp.dirty = _hx_local_2()
            return regUp.dirty

        hxGeomAlgo__Tess2_Sweep.regionAbove(regUp).dirty = _hx_local_3()
        return False

    @staticmethod
    def walkDirtyRegions(tess, regUp):
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eUp = None
        eLo = None
        while True:
            while regLo.dirty:
                regUp = regLo
                regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regLo)
            if (not regUp.dirty):
                regLo = regUp
                regUp = hxGeomAlgo__Tess2_Sweep.regionAbove(regUp)
                if ((regUp is None) or (not regUp.dirty)):
                    return
            regUp.dirty = False
            eUp = regUp.eUp
            eLo = regLo.eUp
            if (eUp.get_Dst() != eLo.get_Dst()):
                if hxGeomAlgo__Tess2_Sweep.checkForLeftSplice(tess, regUp):
                    if regLo.fixUpperEdge:
                        hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, regLo)
                        tess.mesh.delete(eLo)
                        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
                        eLo = regLo.eUp
                    elif regUp.fixUpperEdge:
                        hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, regUp)
                        tess.mesh.delete(eUp)
                        regUp = hxGeomAlgo__Tess2_Sweep.regionAbove(regLo)
                        eUp = regUp.eUp
            if (eUp.Org != eLo.Org):
                if ((((eUp.get_Dst() != eLo.get_Dst()) and (not regUp.fixUpperEdge)) and (not regLo.fixUpperEdge)) and
                    (((eUp.get_Dst() == tess.event) or ((eLo.get_Dst() == tess.event))))):
                    if hxGeomAlgo__Tess2_Sweep.checkForIntersect(tess, regUp):
                        return
                else:
                    hxGeomAlgo__Tess2_Sweep.checkForRightSplice(tess, regUp)
            if ((eUp.Org == eLo.Org) and ((eUp.get_Dst() == eLo.get_Dst()))):
                hxGeomAlgo__Tess2_Sweep.addWinding(eLo, eUp)
                hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, regUp)
                tess.mesh.delete(eUp)
                regUp = hxGeomAlgo__Tess2_Sweep.regionAbove(regLo)

    @staticmethod
    def connectRightVertex(tess, regUp, eBottomLeft):
        eNew = None
        eTopLeft = eBottomLeft.Onext
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eUp = regUp.eUp
        eLo = regLo.eUp
        degenerate = False
        if (eUp.get_Dst() != eLo.get_Dst()):
            hxGeomAlgo__Tess2_Sweep.checkForIntersect(tess, regUp)
        if hxGeomAlgo__Tess2_Geom.vertEq(eUp.Org, tess.event):
            tess.mesh.splice(eTopLeft.get_Oprev(), eUp)
            regUp = hxGeomAlgo__Tess2_Sweep.topLeftRegion(tess, regUp)
            eTopLeft = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp).eUp
            hxGeomAlgo__Tess2_Sweep.finishLeftRegions(tess, hxGeomAlgo__Tess2_Sweep.regionBelow(regUp), regLo)
            degenerate = True
        if hxGeomAlgo__Tess2_Geom.vertEq(eLo.Org, tess.event):
            tess.mesh.splice(eBottomLeft, eLo.get_Oprev())
            eBottomLeft = hxGeomAlgo__Tess2_Sweep.finishLeftRegions(tess, regLo, None)
            degenerate = True
        if degenerate:
            hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, True)
            return
        if hxGeomAlgo__Tess2_Geom.vertLeq(eLo.Org, eUp.Org):
            eNew = eLo.get_Oprev()
        else:
            eNew = eUp
        eNew = tess.mesh.connect(eBottomLeft.get_Lprev(), eNew)
        hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eNew, eNew.Onext, eNew.Onext, False)
        eNew.Sym.activeRegion.fixUpperEdge = True
        hxGeomAlgo__Tess2_Sweep.walkDirtyRegions(tess, regUp)

    @staticmethod
    def connectLeftDegenerate(tess, regUp, vEvent):
        e = regUp.eUp
        if hxGeomAlgo__Tess2_Geom.vertEq(e.Org, vEvent):
            hxGeomAlgo__Tess2_Sweep.spliceMergeVertices(tess, e, vEvent.anEdge)
            return
        if (not hxGeomAlgo__Tess2_Geom.vertEq(e.get_Dst(), vEvent)):
            tess.mesh.splitEdge(e.Sym)
            if regUp.fixUpperEdge:
                tess.mesh.delete(e.Onext)
                regUp.fixUpperEdge = False
            tess.mesh.splice(vEvent.anEdge, e)
            hxGeomAlgo__Tess2_Sweep.sweepEvent(tess, vEvent)
            return
        regUp = hxGeomAlgo__Tess2_Sweep.topRightRegion(regUp)
        reg = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eTopRight = reg.eUp.Sym
        eLast = eTopRight.Onext
        eTopLeft = eLast
        if reg.fixUpperEdge:
            hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, reg)
            tess.mesh.delete(eTopRight)
            eTopRight = eTopLeft.get_Oprev()
        tess.mesh.splice(vEvent.anEdge, eTopRight)
        if (not hxGeomAlgo__Tess2_Geom.edgeGoesLeft(eTopLeft)):
            eTopLeft = None
        hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eTopRight.Onext, eLast, eTopLeft, True)

    @staticmethod
    def connectLeftVertex(tess, vEvent):
        eNew = None
        tmp = hxGeomAlgo__Tess2_ActiveRegion()
        tmp.eUp = vEvent.anEdge.Sym
        regUp = tess.dict.search(tmp).key
        regLo = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        if (regLo is None):
            return
        eUp = regUp.eUp
        eLo = regLo.eUp
        if (hxGeomAlgo__Tess2_Geom.edgeSign(eUp.get_Dst(), vEvent, eUp.Org) == 0.0):
            hxGeomAlgo__Tess2_Sweep.connectLeftDegenerate(tess, regUp, vEvent)
            return
        reg = (regUp if (hxGeomAlgo__Tess2_Geom.vertLeq(eLo.get_Dst(), eUp.get_Dst())) else regLo)
        if (regUp.inside or reg.fixUpperEdge):
            if (reg == regUp):
                eNew = tess.mesh.connect(vEvent.anEdge.Sym, eUp.Lnext)
            else:
                tempHalfEdge = tess.mesh.connect(eLo.get_Dnext(), vEvent.anEdge)
                eNew = tempHalfEdge.Sym
            if reg.fixUpperEdge:
                hxGeomAlgo__Tess2_Sweep.fixUpperEdge(tess, reg, eNew)
            else:
                hxGeomAlgo__Tess2_Sweep.computeWinding(tess, hxGeomAlgo__Tess2_Sweep.addRegionBelow(tess, regUp, eNew))
            hxGeomAlgo__Tess2_Sweep.sweepEvent(tess, vEvent)
        else:
            hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, vEvent.anEdge, vEvent.anEdge, None, True)

    @staticmethod
    def sweepEvent(tess, vEvent):
        tess.event = vEvent
        hxGeomAlgo__Tess2_Sweep.debugEvent(tess)
        e = vEvent.anEdge
        while (e.activeRegion is None):
            e = e.Onext
            if (e == vEvent.anEdge):
                hxGeomAlgo__Tess2_Sweep.connectLeftVertex(tess, vEvent)
                return
        regUp = hxGeomAlgo__Tess2_Sweep.topLeftRegion(tess, e.activeRegion)
        reg = hxGeomAlgo__Tess2_Sweep.regionBelow(regUp)
        eTopLeft = reg.eUp
        eBottomLeft = hxGeomAlgo__Tess2_Sweep.finishLeftRegions(tess, reg, None)
        if (eBottomLeft.Onext == eTopLeft):
            hxGeomAlgo__Tess2_Sweep.connectRightVertex(tess, regUp, eBottomLeft)
        else:
            hxGeomAlgo__Tess2_Sweep.addRightEdges(tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, True)

    @staticmethod
    def addSentinel(tess, smin, smax, t):
        reg = hxGeomAlgo__Tess2_ActiveRegion()
        e = tess.mesh.makeEdge()
        e.Org.s = smax
        e.Org.t = t
        e.get_Dst().s = smin
        e.get_Dst().t = t
        tess.event = e.get_Dst()
        reg.eUp = e
        reg.windingNumber = 0
        reg.inside = False
        reg.fixUpperEdge = False
        reg.sentinel = True
        reg.dirty = False
        reg.nodeUp = tess.dict.insert(reg)

    @staticmethod
    def initEdgeDict(tess):
        tess.dict = hxGeomAlgo__Tess2_Dict(tess, hxGeomAlgo__Tess2_Sweep.edgeLeq)
        w = ((tess.bmax[0] if 0 < len(tess.bmax) else None) - (tess.bmin[0] if 0 < len(tess.bmin) else None))
        h = ((tess.bmax[1] if 1 < len(tess.bmax) else None) - (tess.bmin[1] if 1 < len(tess.bmin) else None))
        smin = ((tess.bmin[0] if 0 < len(tess.bmin) else None) - w)
        smax = ((tess.bmax[0] if 0 < len(tess.bmax) else None) + w)
        tmin = ((tess.bmin[1] if 1 < len(tess.bmin) else None) - h)
        tmax = ((tess.bmax[1] if 1 < len(tess.bmax) else None) + h)
        hxGeomAlgo__Tess2_Sweep.addSentinel(tess, smin, smax, tmin)
        hxGeomAlgo__Tess2_Sweep.addSentinel(tess, smin, smax, tmax)

    @staticmethod
    def doneEdgeDict(tess):
        reg = None
        fixedEdges = 0
        while True:
            reg = tess.dict.min().key
            if (not ((reg is not None))):
                break
            if (not reg.sentinel):
                fixedEdges = (fixedEdges + 1)
                cond = fixedEdges
                cond1 = (cond == 1)
            hxGeomAlgo__Tess2_Sweep.deleteRegion(tess, reg)

    @staticmethod
    def removeDegenerateEdges(tess):
        eNext = None
        eLnext = None
        eHead = tess.mesh.eHead
        e = eHead.next
        while (e != eHead):
            eNext = e.next
            eLnext = e.Lnext
            if (hxGeomAlgo__Tess2_Geom.vertEq(e.Org, e.get_Dst()) and ((e.Lnext.Lnext != e))):
                hxGeomAlgo__Tess2_Sweep.spliceMergeVertices(tess, eLnext, e)
                tess.mesh.delete(e)
                e = eLnext
                eLnext = e.Lnext
            if (eLnext.Lnext == e):
                if (eLnext != e):
                    if ((eLnext == eNext) or ((eLnext == eNext.Sym))):
                        eNext = eNext.next
                    tess.mesh.delete(eLnext)
                if ((e == eNext) or ((e == eNext.Sym))):
                    eNext = eNext.next
                tess.mesh.delete(e)
            e = eNext

    @staticmethod
    def initPriorityQ(tess):
        vertexCount = 0
        vHead = tess.mesh.vHead
        v = vHead.next
        while (v != vHead):
            vertexCount = (vertexCount + 1)
            v = v.next
        vertexCount = (vertexCount + 8)

        def _hx_local_2():
            tess.pq = hxGeomAlgo__Tess2_PriorityQ(vertexCount, hxGeomAlgo__Tess2_Geom.vertLeq)
            return tess.pq

        pq = _hx_local_2()
        vHead = tess.mesh.vHead
        v = vHead.next
        while (v != vHead):
            v.pqHandle = pq.insert(v)
            v = v.next
        if (v != vHead):
            return False
        pq.init()
        return True

    @staticmethod
    def donePriorityQ(tess):
        tess.pq = None

    @staticmethod
    def removeDegenerateFaces(tess, mesh):
        fNext = None
        e = None
        f = mesh.fHead.next
        while (f != mesh.fHead):
            fNext = f.next
            e = f.anEdge
            if (e.Lnext.Lnext == e):
                hxGeomAlgo__Tess2_Sweep.addWinding(e.Onext, e)
                tess.mesh.delete(e)
            f = fNext
        return True

    @staticmethod
    def computeInterior(tess):
        v = None
        vNext = None
        hxGeomAlgo__Tess2_Sweep.removeDegenerateEdges(tess)
        if (not hxGeomAlgo__Tess2_Sweep.initPriorityQ(tess)):
            return False
        hxGeomAlgo__Tess2_Sweep.initEdgeDict(tess)
        pq = tess.pq
        while True:
            v = tess.pq.extractMin()
            if (not ((v is not None))):
                break
            while True:
                vNext = tess.pq.min()
                if ((vNext is None) or (not hxGeomAlgo__Tess2_Geom.vertEq(vNext, v))):
                    break
                vNext = tess.pq.extractMin()
                hxGeomAlgo__Tess2_Sweep.spliceMergeVertices(tess, v.anEdge, vNext.anEdge)
            hxGeomAlgo__Tess2_Sweep.sweepEvent(tess, v)
        tess.event = tess.dict.min().key.eUp.Org
        hxGeomAlgo__Tess2_Sweep.debugEvent(tess)
        hxGeomAlgo__Tess2_Sweep.doneEdgeDict(tess)
        hxGeomAlgo__Tess2_Sweep.donePriorityQ(tess)
        if (not hxGeomAlgo__Tess2_Sweep.removeDegenerateFaces(tess, tess.mesh)):
            return False
        tess.mesh.check()
        return True


class hxGeomAlgo_Tesselator:
    _hx_class_name = "hxGeomAlgo.Tesselator"
    __slots__ = ("mesh", "normal", "sUnit", "tUnit", "bmin", "bmax", "windingRule", "dict", "pq", "event",
                 "vertexIndexCounter", "vertices", "vertexIndices", "vertexCount", "elements", "elementCount")
    _hx_fields = [
        "mesh", "normal", "sUnit", "tUnit", "bmin", "bmax", "windingRule", "dict", "pq", "event", "vertexIndexCounter",
        "vertices", "vertexIndices", "vertexCount", "elements", "elementCount"
    ]
    _hx_methods = [
        "dot_", "normalize_", "longAxis_", "computeNormal_", "checkOrientation_", "projectPolygon_", "addWinding_",
        "tessellateMonoRegion_", "tessellateInterior_", "refineDelaunay_", "discardExterior_", "setWindingNumber_",
        "getNeighbourFace_", "outputPolymesh_", "outputContours_", "addContour", "tesselate"
    ]

    def __init__(self):
        self.elementCount = 0
        self.elements = []
        self.vertexCount = 0
        self.vertexIndices = []
        self.vertices = []
        self.vertexIndexCounter = 0
        self.event = None
        self.pq = None
        self.dict = None
        self.bmax = [0.0, 0.0]
        self.bmin = [0.0, 0.0]
        self.tUnit = [0.0, 0.0, 0.0]
        self.sUnit = [0.0, 0.0, 0.0]
        self.normal = [0.0, 0.0, 0.0]
        self.mesh = None
        self.windingRule = hxGeomAlgo_WindingRule.ODD

    def dot_(self, u, v):
        return ((((u[0] if 0 < len(u) else None) * (v[0] if 0 < len(v) else None)) +
                 (((u[1] if 1 < len(u) else None) * (v[1] if 1 < len(v) else None)))) +
                (((u[2] if 2 < len(u) else None) * (v[2] if 2 < len(v) else None))))

    def normalize_(self, v):
        _hx_len = ((((v[0] if 0 < len(v) else None) * (v[0] if 0 < len(v) else None)) +
                    (((v[1] if 1 < len(v) else None) * (v[1] if 1 < len(v) else None)))) +
                   (((v[2] if 2 < len(v) else None) * (v[2] if 2 < len(v) else None))))
        _hx_len = (Math.NaN if ((_hx_len < 0)) else python_lib_Math.sqrt(_hx_len))
        _hx_local_0 = v
        _hx_local_1 = 0
        _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 / _hx_len))
        (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        _hx_local_3 = v
        _hx_local_4 = 1
        _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 / _hx_len))
        (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
        _hx_local_6 = v
        _hx_local_7 = 2
        _hx_local_8 = (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)
        python_internal_ArrayImpl._set(_hx_local_6, _hx_local_7, (_hx_local_8 / _hx_len))
        (_hx_local_6[_hx_local_7] if _hx_local_7 >= 0 and _hx_local_7 < len(_hx_local_6) else None)

    def longAxis_(self, v):
        i = 0
        if (Reflect.field(Math, "fabs")((v[1] if 1 < len(v) else None)) > Reflect.field(Math, "fabs")(
            (v[0] if 0 < len(v) else None))):
            i = 1
        if (Reflect.field(Math, "fabs")((v[2] if 2 < len(v) else None)) > Reflect.field(Math, "fabs")(
            (v[i] if i >= 0 and i < len(v) else None))):
            i = 2
        return i

    def computeNormal_(self, norm):
        c = None
        tLen2 = None
        maxVal = [.0, .0, .0]
        minVal = [.0, .0, .0]
        d1 = [.0, .0, .0]
        d2_0 = .0
        d2_1 = .0
        d2_2 = .0
        tNorm_0 = .0
        tNorm_1 = .0
        tNorm_2 = .0
        maxVert = [None, None, None]
        minVert = [None, None, None]
        vHead = self.mesh.vHead
        v = vHead.next
        c = (v.coords[0] if 0 < len(v.coords) else None)
        python_internal_ArrayImpl._set(minVal, 0, c)
        python_internal_ArrayImpl._set(minVert, 0, v)
        python_internal_ArrayImpl._set(maxVal, 0, c)
        python_internal_ArrayImpl._set(maxVert, 0, v)
        c = (v.coords[1] if 1 < len(v.coords) else None)
        python_internal_ArrayImpl._set(minVal, 1, c)
        python_internal_ArrayImpl._set(minVert, 1, v)
        python_internal_ArrayImpl._set(maxVal, 1, c)
        python_internal_ArrayImpl._set(maxVert, 1, v)
        c = (v.coords[2] if 2 < len(v.coords) else None)
        python_internal_ArrayImpl._set(minVal, 2, c)
        python_internal_ArrayImpl._set(minVert, 2, v)
        python_internal_ArrayImpl._set(maxVal, 2, c)
        python_internal_ArrayImpl._set(maxVert, 2, v)
        v = vHead.next
        while (v != vHead):
            c = (v.coords[0] if 0 < len(v.coords) else None)
            if (c < (minVal[0] if 0 < len(minVal) else None)):
                python_internal_ArrayImpl._set(minVal, 0, c)
                python_internal_ArrayImpl._set(minVert, 0, v)
            if (c > (maxVal[0] if 0 < len(maxVal) else None)):
                python_internal_ArrayImpl._set(maxVal, 0, c)
                python_internal_ArrayImpl._set(maxVert, 0, v)
            c = (v.coords[1] if 1 < len(v.coords) else None)
            if (c < (minVal[1] if 1 < len(minVal) else None)):
                python_internal_ArrayImpl._set(minVal, 1, c)
                python_internal_ArrayImpl._set(minVert, 1, v)
            if (c > (maxVal[1] if 1 < len(maxVal) else None)):
                python_internal_ArrayImpl._set(maxVal, 1, c)
                python_internal_ArrayImpl._set(maxVert, 1, v)
            c = (v.coords[2] if 2 < len(v.coords) else None)
            if (c < (minVal[2] if 2 < len(minVal) else None)):
                python_internal_ArrayImpl._set(minVal, 2, c)
                python_internal_ArrayImpl._set(minVert, 2, v)
            if (c > (maxVal[2] if 2 < len(maxVal) else None)):
                python_internal_ArrayImpl._set(maxVal, 2, c)
                python_internal_ArrayImpl._set(maxVert, 2, v)
            v = v.next
        i = 0
        if (((maxVal[1] if 1 < len(maxVal) else None) - (minVal[1] if 1 < len(minVal) else None)) >
            (((maxVal[0] if 0 < len(maxVal) else None) - (minVal[0] if 0 < len(minVal) else None)))):
            i = 1
        if (((maxVal[2] if 2 < len(maxVal) else None) - (minVal[2] if 2 < len(minVal) else None)) >
            (((maxVal[i] if i >= 0 and i < len(maxVal) else None) -
              (minVal[i] if i >= 0 and i < len(minVal) else None)))):
            i = 2
        if ((minVal[i] if i >= 0 and i < len(minVal) else None) >=
            (maxVal[i] if i >= 0 and i < len(maxVal) else None)):
            python_internal_ArrayImpl._set(norm, 0, 0)
            python_internal_ArrayImpl._set(norm, 1, 0)
            python_internal_ArrayImpl._set(norm, 2, 1)
            return
        maxLen2 = .0
        v1 = (minVert[i] if i >= 0 and i < len(minVert) else None)
        v2 = (maxVert[i] if i >= 0 and i < len(maxVert) else None)
        python_internal_ArrayImpl._set(d1, 0, ((v1.coords[0] if 0 < len(v1.coords) else None) -
                                               (v2.coords[0] if 0 < len(v2.coords) else None)))
        python_internal_ArrayImpl._set(d1, 1, ((v1.coords[1] if 1 < len(v1.coords) else None) -
                                               (v2.coords[1] if 1 < len(v2.coords) else None)))
        python_internal_ArrayImpl._set(d1, 2, ((v1.coords[2] if 2 < len(v1.coords) else None) -
                                               (v2.coords[2] if 2 < len(v2.coords) else None)))
        v = vHead.next
        while (v != vHead):
            d2_0 = ((v.coords[0] if 0 < len(v.coords) else None) - (v2.coords[0] if 0 < len(v2.coords) else None))
            d2_1 = ((v.coords[1] if 1 < len(v.coords) else None) - (v2.coords[1] if 1 < len(v2.coords) else None))
            d2_2 = ((v.coords[2] if 2 < len(v.coords) else None) - (v2.coords[2] if 2 < len(v2.coords) else None))
            tNorm_0 = (((d1[1] if 1 < len(d1) else None) * d2_2) - (((d1[2] if 2 < len(d1) else None) * d2_1)))
            tNorm_1 = (((d1[2] if 2 < len(d1) else None) * d2_0) - (((d1[0] if 0 < len(d1) else None) * d2_2)))
            tNorm_2 = (((d1[0] if 0 < len(d1) else None) * d2_1) - (((d1[1] if 1 < len(d1) else None) * d2_0)))
            tLen2 = (((tNorm_0 * tNorm_0) + ((tNorm_1 * tNorm_1))) + ((tNorm_2 * tNorm_2)))
            if (tLen2 > maxLen2):
                maxLen2 = tLen2
                python_internal_ArrayImpl._set(norm, 0, tNorm_0)
                python_internal_ArrayImpl._set(norm, 1, tNorm_1)
                python_internal_ArrayImpl._set(norm, 2, tNorm_2)
            v = v.next
        if (maxLen2 <= 0):

            def _hx_local_1():

                def _hx_local_0():
                    python_internal_ArrayImpl._set(norm, 2, 0)
                    return (norm[2] if 2 < len(norm) else None)

                python_internal_ArrayImpl._set(norm, 1, _hx_local_0())
                return (norm[1] if 1 < len(norm) else None)

            python_internal_ArrayImpl._set(norm, 0, _hx_local_1())
            python_internal_ArrayImpl._set(norm, self.longAxis_(d1), 1)

    def checkOrientation_(self):
        fHead = self.mesh.fHead
        v = None
        vHead = self.mesh.vHead
        e = None
        area = .0
        f = fHead.next
        while (f != fHead):
            e = f.anEdge
            if (e.winding <= 0):
                f = f.next
                continue
            while True:
                area = (area + ((((e.Org.s - e.get_Dst().s)) * ((e.Org.t + e.get_Dst().t)))))
                e = e.Lnext
                if (not ((e != f.anEdge))):
                    break
            f = f.next
        if (area < 0):
            v = vHead.next
            while (v != vHead):
                v.t = -v.t
                v = v.next
            python_internal_ArrayImpl._set(self.tUnit, 0, -(self.tUnit[0] if 0 < len(self.tUnit) else None))
            python_internal_ArrayImpl._set(self.tUnit, 1, -(self.tUnit[1] if 1 < len(self.tUnit) else None))
            python_internal_ArrayImpl._set(self.tUnit, 2, -(self.tUnit[2] if 2 < len(self.tUnit) else None))

    def projectPolygon_(self):
        vHead = self.mesh.vHead
        norm = [.0, .0, .0]
        computedNormal = False
        python_internal_ArrayImpl._set(norm, 0, (self.normal[0] if 0 < len(self.normal) else None))
        python_internal_ArrayImpl._set(norm, 1, (self.normal[1] if 1 < len(self.normal) else None))
        python_internal_ArrayImpl._set(norm, 2, (self.normal[2] if 2 < len(self.normal) else None))
        if ((((norm[0] if 0 < len(norm) else None) == 0.0) and (((norm[1] if 1 < len(norm) else None) == 0.0))) and
            (((norm[2] if 2 < len(norm) else None) == 0.0))):
            self.computeNormal_(norm)
            computedNormal = True
        sUnit = self.sUnit
        tUnit = self.tUnit
        i = self.longAxis_(norm)
        python_internal_ArrayImpl._set(sUnit, i, 0)
        python_internal_ArrayImpl._set(sUnit, HxOverrides.mod(((i + 1)), 3), 1.0)
        python_internal_ArrayImpl._set(sUnit, HxOverrides.mod(((i + 2)), 3), 0.0)
        python_internal_ArrayImpl._set(tUnit, i, 0)
        python_internal_ArrayImpl._set(tUnit, HxOverrides.mod(((i + 1)), 3), 0.0)
        python_internal_ArrayImpl._set(tUnit, HxOverrides.mod(((i + 2)), 3),
                                       (1.0 if (((norm[i] if i >= 0 and i < len(norm) else None) > 0)) else -1.0))
        v = vHead.next
        while (v != vHead):
            v.s = self.dot_(v.coords, sUnit)
            v.t = self.dot_(v.coords, tUnit)
            v = v.next
        if computedNormal:
            self.checkOrientation_()
        first = True
        v = vHead.next
        while (v != vHead):
            if first:

                def _hx_local_0():
                    python_internal_ArrayImpl._set(self.bmax, 0, v.s)
                    return (self.bmax[0] if 0 < len(self.bmax) else None)

                tmp = _hx_local_0()
                python_internal_ArrayImpl._set(self.bmin, 0, tmp)

                def _hx_local_1():
                    python_internal_ArrayImpl._set(self.bmax, 1, v.t)
                    return (self.bmax[1] if 1 < len(self.bmax) else None)

                tmp1 = _hx_local_1()
                python_internal_ArrayImpl._set(self.bmin, 1, tmp1)
                first = False
            else:
                if (v.s < (self.bmin[0] if 0 < len(self.bmin) else None)):
                    python_internal_ArrayImpl._set(self.bmin, 0, v.s)
                if (v.s > (self.bmax[0] if 0 < len(self.bmax) else None)):
                    python_internal_ArrayImpl._set(self.bmax, 0, v.s)
                if (v.t < (self.bmin[1] if 1 < len(self.bmin) else None)):
                    python_internal_ArrayImpl._set(self.bmin, 1, v.t)
                if (v.t > (self.bmax[1] if 1 < len(self.bmax) else None)):
                    python_internal_ArrayImpl._set(self.bmax, 1, v.t)
            v = v.next

    def addWinding_(self, eDst, eSrc):
        eDst.winding = (eDst.winding + eSrc.winding)
        _hx_local_1 = eDst.Sym
        _hx_local_2 = _hx_local_1.winding
        _hx_local_1.winding = (_hx_local_2 + eSrc.Sym.winding)
        _hx_local_1.winding

    def tessellateMonoRegion_(self, mesh, face):
        up = face.anEdge
        while hxGeomAlgo__Tess2_Geom.vertLeq(up.get_Dst(), up.Org):
            up = up.get_Lprev()
        while hxGeomAlgo__Tess2_Geom.vertLeq(up.Org, up.get_Dst()):
            up = up.Lnext
        lo = up.get_Lprev()
        while (up.Lnext != lo):
            if hxGeomAlgo__Tess2_Geom.vertLeq(up.get_Dst(), lo.Org):
                while ((lo.Lnext != up) and
                       ((hxGeomAlgo__Tess2_Geom.edgeGoesLeft(lo.Lnext) or
                         ((hxGeomAlgo__Tess2_Geom.edgeSign(lo.Org, lo.get_Dst(), lo.Lnext.get_Dst()) <= 0.0))))):
                    tempHalfEdge = mesh.connect(lo.Lnext, lo)
                    lo = tempHalfEdge.Sym
                lo = lo.get_Lprev()
            else:
                while ((lo.Lnext != up) and ((hxGeomAlgo__Tess2_Geom.edgeGoesRight(up.get_Lprev()) or
                                              ((hxGeomAlgo__Tess2_Geom.edgeSign(up.get_Dst(), up.Org,
                                                                                up.get_Lprev().Org) >= 0.0))))):
                    tempHalfEdge1 = mesh.connect(up, up.get_Lprev())
                    up = tempHalfEdge1.Sym
                up = up.Lnext
        while (lo.Lnext.Lnext != up):
            tempHalfEdge2 = mesh.connect(lo.Lnext, lo)
            lo = tempHalfEdge2.Sym
        return True

    def tessellateInterior_(self, mesh):
        next = None
        f = mesh.fHead.next
        while (f != mesh.fHead):
            next = f.next
            if f.inside:
                if (not self.tessellateMonoRegion_(mesh, f)):
                    return False
            f = next
        return True

    def refineDelaunay_(self, mesh):
        stack = []
        e = None
        edges_0 = None
        edges_1 = None
        edges_2 = None
        edges_3 = None
        f = mesh.fHead.next
        while (f != mesh.fHead):
            if f.inside:
                e = f.anEdge
                while True:
                    e.mark = hxGeomAlgo__Tess2_Geom.edgeIsInternal(e)
                    if (e.mark and (not e.Sym.mark)):
                        stack.append(e)
                    e = e.Lnext
                    if (not ((e != f.anEdge))):
                        break
            f = f.next
        while (len(stack) > 0):
            e = (None if ((len(stack) == 0)) else stack.pop())

            def _hx_local_0():
                e.Sym.mark = False
                return e.Sym.mark

            e.mark = _hx_local_0()
            if (not hxGeomAlgo__Tess2_Geom.edgeIsLocallyDelaunay(e)):
                hxGeomAlgo__Tess2_TessMesh.flipEdge(mesh, e)
                edges_0 = e.Lnext
                edges_1 = e.get_Lprev()
                edges_2 = e.Sym.Lnext
                edges_3 = e.Sym.get_Lprev()
                if ((not edges_0.mark) and hxGeomAlgo__Tess2_Geom.edgeIsInternal(edges_0)):

                    def _hx_local_1():
                        edges_0.Sym.mark = True
                        return edges_0.Sym.mark

                    edges_0.mark = _hx_local_1()
                    stack.append(edges_0)
                if ((not edges_1.mark) and hxGeomAlgo__Tess2_Geom.edgeIsInternal(edges_1)):

                    def _hx_local_2():
                        edges_1.Sym.mark = True
                        return edges_1.Sym.mark

                    edges_1.mark = _hx_local_2()
                    stack.append(edges_1)
                if ((not edges_2.mark) and hxGeomAlgo__Tess2_Geom.edgeIsInternal(edges_2)):

                    def _hx_local_3():
                        edges_2.Sym.mark = True
                        return edges_2.Sym.mark

                    edges_2.mark = _hx_local_3()
                    stack.append(edges_2)
        _g = 0
        while (_g < len(stack)):
            e1 = (stack[_g] if _g >= 0 and _g < len(stack) else None)
            _g = (_g + 1)
            if (len(stack) != 0):
                stack.pop()
        stack = None

    def discardExterior_(self, mesh):
        next = None
        f = mesh.fHead.next
        while (f != mesh.fHead):
            next = f.next
            if (not f.inside):
                mesh.zapFace(f)
            f = next

    def setWindingNumber_(self, mesh, value, keepOnlyBoundary):
        eNext = None
        e = mesh.eHead.next
        while (e != mesh.eHead):
            eNext = e.next
            if (e.get_Rface().inside != e.Lface.inside):
                e.winding = (value if (e.Lface.inside) else -value)
            elif (not keepOnlyBoundary):
                e.winding = 0
            else:
                mesh.delete(e)
            e = eNext

    def getNeighbourFace_(self, edge):
        if (edge.get_Rface() is None):
            return -1
        if (not edge.get_Rface().inside):
            return -1
        return edge.get_Rface().n

    def outputPolymesh_(self, mesh, resultsType, polySize, vertexDim):
        edge = None
        maxFaceCount = 0
        maxVertexCount = 0
        faceVerts = None
        i = None
        elements = 0
        vert = None
        if (polySize > 3):
            mesh.mergeConvexFaces(polySize)
        v = mesh.vHead.next
        while (v != mesh.vHead):
            v.n = -1
            v = v.next
        f = mesh.fHead.next
        while (f != mesh.fHead):
            f.n = -1
            if (not f.inside):
                f = f.next
                continue
            edge = f.anEdge
            faceVerts = 0
            while True:
                v = edge.Org
                if (v.n == -1):
                    v.n = maxVertexCount
                    maxVertexCount = (maxVertexCount + 1)
                faceVerts = (faceVerts + 1)
                edge = edge.Lnext
                if (not ((edge != f.anEdge))):
                    break
            f.n = maxFaceCount
            maxFaceCount = (maxFaceCount + 1)
            f = f.next
        self.elementCount = maxFaceCount
        if (resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS):
            maxFaceCount = (maxFaceCount * 2)
        self.elements = []
        self.vertexCount = maxVertexCount
        self.vertices = []
        self.vertexIndices = []
        v = mesh.vHead.next
        while (v != mesh.vHead):
            if (v.n != -1):
                idx = (v.n * vertexDim)
                python_internal_ArrayImpl._set(self.vertices, idx, (v.coords[0] if 0 < len(v.coords) else None))
                python_internal_ArrayImpl._set(self.vertices, (idx + 1), (v.coords[1] if 1 < len(v.coords) else None))
                if (vertexDim > 2):
                    python_internal_ArrayImpl._set(self.vertices, (idx + 2),
                                                   (v.coords[2] if 2 < len(v.coords) else None))
                python_internal_ArrayImpl._set(self.vertexIndices, v.n, v.idx)
            v = v.next
        nel = 0
        f = mesh.fHead.next
        while (f != mesh.fHead):
            if (not f.inside):
                f = f.next
                continue
            edge = f.anEdge
            faceVerts = 0
            while True:
                v = edge.Org
                tmp = nel
                nel = (nel + 1)
                python_internal_ArrayImpl._set(self.elements, tmp, v.n)
                faceVerts = (faceVerts + 1)
                edge = edge.Lnext
                if (not ((edge != f.anEdge))):
                    break
            _g = faceVerts
            _g1 = polySize
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                tmp1 = nel
                nel = (nel + 1)
                python_internal_ArrayImpl._set(self.elements, tmp1, -1)
            if (resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS):
                edge = f.anEdge
                while True:
                    tmp2 = nel
                    nel = (nel + 1)
                    python_internal_ArrayImpl._set(self.elements, tmp2, self.getNeighbourFace_(edge))
                    edge = edge.Lnext
                    if (not ((edge != f.anEdge))):
                        break
                _g2 = faceVerts
                _g3 = polySize
                while (_g2 < _g3):
                    i2 = _g2
                    _g2 = (_g2 + 1)
                    tmp3 = nel
                    nel = (nel + 1)
                    python_internal_ArrayImpl._set(self.elements, tmp3, -1)
            f = f.next

    def outputContours_(self, mesh, vertexDim):
        edge = None
        start = None
        verts = None
        elements = None
        vertInds = None
        startVert = 0
        vertCount = 0
        self.vertexCount = 0
        self.elementCount = 0
        f = mesh.fHead.next
        while (f != mesh.fHead):
            if (not f.inside):
                f = f.next
                continue
            edge = f.anEdge
            start = edge
            while True:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.vertexCount
                _hx_local_0.vertexCount = (_hx_local_1 + 1)
                _hx_local_1
                edge = edge.Lnext
                if (not ((edge != start))):
                    break
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.elementCount
            _hx_local_2.elementCount = (_hx_local_3 + 1)
            _hx_local_3
            f = f.next
        self.elements = []
        self.vertices = []
        self.vertexIndices = []
        nv = 0
        nvi = 0
        nel = 0
        startVert = 0
        f = mesh.fHead.next
        while (f != mesh.fHead):
            if (not f.inside):
                f = f.next
                continue
            vertCount = 0
            edge = f.anEdge
            start = edge
            while True:
                tmp = nv
                nv = (nv + 1)
                python_internal_ArrayImpl._set(self.vertices, tmp, python_internal_ArrayImpl._get(edge.Org.coords, 0))
                tmp1 = nv
                nv = (nv + 1)
                python_internal_ArrayImpl._set(self.vertices, tmp1, python_internal_ArrayImpl._get(edge.Org.coords, 1))
                if (vertexDim > 2):
                    tmp2 = nv
                    nv = (nv + 1)
                    python_internal_ArrayImpl._set(self.vertices, tmp2,
                                                   python_internal_ArrayImpl._get(edge.Org.coords, 2))
                tmp3 = nvi
                nvi = (nvi + 1)
                python_internal_ArrayImpl._set(self.vertexIndices, tmp3, edge.Org.idx)
                vertCount = (vertCount + 1)
                edge = edge.Lnext
                if (not ((edge != start))):
                    break
            tmp4 = nel
            nel = (nel + 1)
            python_internal_ArrayImpl._set(self.elements, tmp4, startVert)
            tmp5 = nel
            nel = (nel + 1)
            python_internal_ArrayImpl._set(self.elements, tmp5, vertCount)
            startVert = (startVert + vertCount)
            f = f.next

    def addContour(self, vertexDim, vertices):
        if (self.mesh is None):
            self.mesh = hxGeomAlgo__Tess2_TessMesh()
        if (vertexDim < 2):
            vertexDim = 2
        if (vertexDim > 3):
            vertexDim = 3
        e = None
        i = 0
        while (i < len(vertices)):
            if (e is None):
                e = self.mesh.makeEdge()
                self.mesh.splice(e, e.Sym)
            else:
                self.mesh.splitEdge(e)
                e = e.Lnext
            python_internal_ArrayImpl._set(e.Org.coords, 0, (vertices[i] if i >= 0 and i < len(vertices) else None))
            python_internal_ArrayImpl._set(e.Org.coords, 1, python_internal_ArrayImpl._get(vertices, (i + 1)))
            if (vertexDim > 2):
                python_internal_ArrayImpl._set(e.Org.coords, 2, python_internal_ArrayImpl._get(vertices, (i + 2)))
            else:
                python_internal_ArrayImpl._set(e.Org.coords, 2, 0.0)

            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.vertexIndexCounter
                _hx_local_0.vertexIndexCounter = (_hx_local_1 + 1)
                return _hx_local_1

            e.Org.idx = _hx_local_2()
            e.winding = 1
            e.Sym.winding = -1
            i = (i + vertexDim)

    def tesselate(self, windingRule, resultType, polySize, vertexDim, normal=None):
        self.vertices = []
        self.elements = []
        self.vertexIndices = []
        self.vertexIndexCounter = 0
        if (normal is not None):
            python_internal_ArrayImpl._set(self.normal, 0, (normal[0] if 0 < len(normal) else None))
            python_internal_ArrayImpl._set(self.normal, 1, (normal[1] if 1 < len(normal) else None))
            python_internal_ArrayImpl._set(self.normal, 2, (normal[2] if 2 < len(normal) else None))
        self.windingRule = windingRule
        if (vertexDim < 2):
            vertexDim = 2
        if (vertexDim > 3):
            vertexDim = 3
        if (self.mesh is None):
            return False
        self.projectPolygon_()
        hxGeomAlgo__Tess2_Sweep.computeInterior(self)
        mesh = self.mesh
        if (resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS):
            self.setWindingNumber_(mesh, 1, True)
        else:
            self.tessellateInterior_(mesh)
            if (resultType == hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY):
                self.refineDelaunay_(mesh)
                polySize = 3
        mesh.check()
        if (resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS):
            self.outputContours_(mesh, vertexDim)
        else:
            self.outputPolymesh_(mesh, resultType, polySize, vertexDim)
        return True


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = [
        "keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass",
        "getClassFields", "prefixLength", "unhandleKeywords"
    ]

    @staticmethod
    def toString1(o, s):
        if (o is None):
            return "null"
        if isinstance(o, str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o, bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o, int) and (not isinstance(o, bool))):
            return str(o)
        if isinstance(o, float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o, list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(
                    ((("null" if prefix is None else prefix) +
                      HxOverrides.stringOrNull(python_Boot.toString1(
                          (o1[i] if i >= 0 and i < len(o1) else None), s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o, "toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            pass
        if hasattr(o, "__class__"):
            if isinstance(o, _hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(
                            python_Boot.toString1(python_Boot.simpleField(o, f),
                                                  (("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o, Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(
                            ((("null" if prefix1 is None else prefix1) +
                              HxOverrides.stringOrNull(python_Boot.toString1(o2.params[i1], s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) +
                            ")")
                else:
                    return o2.tag
            if hasattr(o, "_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(
                            python_Boot.toString1(python_Boot.simpleField(o, f1),
                                                  (("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") +
                               HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(
                            python_Boot.toString1(python_Boot.simpleField(o, f2),
                                                  (("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") +
                               HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o, "__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                pass
            if hasattr(o, "__str__"):
                return o.__str__([])
            if hasattr(o, "__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o, "_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o, _hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o, "__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o, field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                  (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                          ((ord(field[1]) == 95))) and
                                         ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o, field1):
            return getattr(o, field1)
        else:
            return None

    @staticmethod
    def field(o, field):
        if (field is None):
            return None
        if isinstance(o, str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o, HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o, HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o, HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o, HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o, HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o, HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o, HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o, HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o, HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o, HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field2) if (hasattr(o, field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                          (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                  ((ord(field[1]) == 95))) and
                                                 ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o, field2) if (hasattr(o, field2)) else None)
        elif isinstance(o, list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o, python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                              (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                      ((ord(field[1]) == 95))) and
                                                     ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o, field4) if (hasattr(o, field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                          (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                                  ((ord(field[1]) == 95))) and
                                                 ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o, field4) if (hasattr(o, field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else
                      (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and
                                              ((ord(field[1]) == 95))) and
                                             ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o, field5) if (hasattr(o, field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c, "_hx_fields")) else [])
        if hasattr(c, "_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c, "_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c, "_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name, 0, python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name, python_Boot.prefixLength, None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = [
        "concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove",
        "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"
    ]

    @staticmethod
    def concat(a1, a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a, x, fromIndex=None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i], x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a, x, fromIndex=None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else
                                                    (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l], x):
                return l
        return -1

    @staticmethod
    def join(x, sep):
        return sep.join([python_Boot.toString1(x1, '') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1, '') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x, e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x, e):
        x.insert(0, e)

    @staticmethod
    def remove(x, e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x, pos, end=None):
        return x[pos:end]

    @staticmethod
    def sort(x, f):
        x.sort(key=python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x, pos, _hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x, f):
        return list(map(f, x))

    @staticmethod
    def filter(x, f):
        return list(filter(f, x))

    @staticmethod
    def insert(a, pos, x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x, idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x, idx, v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "modf", "mod"]

    @staticmethod
    def eq(a, b):
        if (isinstance(a, list) or isinstance(b, list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def modf(a, b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a, b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self, obj, func):
        self.obj = obj
        self.func = func

    def __call__(self, *args):
        return self.func(self.obj, *args)


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = [
        "split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString",
        "substring", "substr"
    ]

    @staticmethod
    def split(s, d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s, index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s, index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s, _hx_str, startIndex=None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0, ((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s, _hx_str, startIndex=None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s, startIndex, endIndex=None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s, startIndex, _hx_len=None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

hxGeomAlgo_HomogCoord.INFINITY = hxGeomAlgo_HomogCoord()
hxGeomAlgo__HxPoint_HxPoint_Impl_.EMPTY = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(Math.NaN, Math.NaN)
hxGeomAlgo_PolyTools.point = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
hxGeomAlgo_PolyTools.zero = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(0, 0)
hxGeomAlgo_PolyTools.EPSILON = .00000001
python_Boot.keywords = set([
    "and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None",
    "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally",
    "is", "try", "def", "for", "lambda", "while"
])
python_Boot.prefixLength = len("_hx_")
