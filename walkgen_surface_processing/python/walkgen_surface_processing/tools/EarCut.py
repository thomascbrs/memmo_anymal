# Generated by Haxe 4.0.5
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import functools as python_lib_Functools
import re as python_lib_Re


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["split"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x3 = HxString.substr(s,lastEnd,None)
            ret.append(x3)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]



class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has



class haxe_ds_ArraySort:
    _hx_class_name = "haxe.ds.ArraySort"
    __slots__ = ()
    _hx_statics = ["sort", "rec", "doMerge", "rotate", "gcd", "upper", "lower", "swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g = (_hx_from + 1)
            _g1 = to
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)


class hxGeomAlgo_Debug:
    _hx_class_name = "hxGeomAlgo.Debug"
    __slots__ = ()
    _hx_statics = ["assert"]

    @staticmethod
    def _hx_assert(cond,message = None,pos = None):
        return


class hxGeomAlgo_EarCut:
    _hx_class_name = "hxGeomAlgo.EarCut"
    __slots__ = ()
    _hx_statics = ["removeHoles", "triangulate", "earcut", "linkedList", "filterPoints", "earcutLinked", "isEar", "isEarHashed", "cureLocalIntersections", "splitEarcut", "eliminateHoles", "compareX", "eliminateHole", "findHoleBridge", "indexCurve", "sortLinked", "zOrder", "getLeftmost", "pointInTriangle", "isValidDiagonal", "area", "equals", "intersects", "intersectsPolygon", "locallyInside", "middleInside", "splitPolygon", "insertNode", "removeNode", "deviation", "signedArea", "flatten", "polygonize", "addTriangle"]

    @staticmethod
    def removeHoles(poly, holes):
        data = hxGeomAlgo_PolyTools.toFloatArray(poly)
        holeIndices = None
        allVertices = poly
        if ((holes is not None) and ((len(holes) > 0))):
            allVertices = (poly + [])
            hxGeomAlgo_PolyTools.flatten(holes,allVertices)
            holeIndices = []
            holeIdx = len(poly)
            _g = 0
            while (_g < len(holes)):
                hole = (holes[_g] if _g >= 0 and _g < len(holes) else None)
                _g = (_g + 1)
                _g1 = 0
                _g11 = hxGeomAlgo_PolyTools.toFloatArray(hole)
                while (_g1 < len(_g11)):
                    f = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                    _g1 = (_g1 + 1)
                    data.append(f)
                holeIndices.append(holeIdx)
                holeIdx = (holeIdx + len(hole))
        dim = 2
        hasHoles = ((holeIndices is not None) and ((len(holeIndices) > 0)))
        outerLen = (((holeIndices[0] if 0 < len(holeIndices) else None) * dim) if hasHoles else len(data))
        outerNode = hxGeomAlgo_EarCut.linkedList(data,0,outerLen,dim,True)
        triangles = []
        if (outerNode is None):
            return triangles
        outerNode = hxGeomAlgo_EarCut.filterPoints(outerNode)
        size = Math.NaN
        y = size
        x = y
        maxY = x
        maxX = maxY
        minY = maxX
        minX = minY
        outerNode = hxGeomAlgo_EarCut.eliminateHoles(data,holeIndices,outerNode,dim)

        ear = outerNode
        stop = ear
        prev = None
        next = None
        i = 0
        points = []
        while (ear.prev != ear.next):
            points.append([ear.x, ear.y])
            prev = ear.prev
            next = ear.next

            ear = next
            if (ear == stop):
                break

        return points

    @staticmethod
    def triangulate(poly,holes = None):
        data = hxGeomAlgo_PolyTools.toFloatArray(poly)
        holeIndices = None
        allVertices = poly
        if ((holes is not None) and ((len(holes) > 0))):
            allVertices = (poly + [])
            hxGeomAlgo_PolyTools.flatten(holes,allVertices)
            holeIndices = []
            holeIdx = len(poly)
            _g = 0
            while (_g < len(holes)):
                hole = (holes[_g] if _g >= 0 and _g < len(holes) else None)
                _g = (_g + 1)
                _g1 = 0
                _g11 = hxGeomAlgo_PolyTools.toFloatArray(hole)
                while (_g1 < len(_g11)):
                    f = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                    _g1 = (_g1 + 1)
                    data.append(f)
                holeIndices.append(holeIdx)
                holeIdx = (holeIdx + len(hole))
        triIndices = hxGeomAlgo_EarCut.earcut(data,holeIndices)
        res = []
        i = 0
        while (i < len(triIndices)):
            tri = [python_internal_ArrayImpl._get(allVertices, (triIndices[i] if i >= 0 and i < len(triIndices) else None)), python_internal_ArrayImpl._get(allVertices, python_internal_ArrayImpl._get(triIndices, (i + 1))), python_internal_ArrayImpl._get(allVertices, python_internal_ArrayImpl._get(triIndices, (i + 2)))]
            res.append(tri)
            i = (i + 3)
        return res

    @staticmethod
    def earcut(data,holeIndices = None,dim = None):
        if (dim is None):
            dim = 2
        hasHoles = ((holeIndices is not None) and ((len(holeIndices) > 0)))
        outerLen = (((holeIndices[0] if 0 < len(holeIndices) else None) * dim) if hasHoles else len(data))
        outerNode = hxGeomAlgo_EarCut.linkedList(data,0,outerLen,dim,True)
        triangles = []
        if (outerNode is None):
            return triangles
        outerNode = hxGeomAlgo_EarCut.filterPoints(outerNode)
        size = Math.NaN
        y = size
        x = y
        maxY = x
        maxX = maxY
        minY = maxX
        minX = minY
        if hasHoles:
            outerNode = hxGeomAlgo_EarCut.eliminateHoles(data,holeIndices,outerNode,dim)
        if (len(data) > ((80 * dim))):
            maxX = (data[0] if 0 < len(data) else None)
            minX = maxX
            maxY = (data[1] if 1 < len(data) else None)
            minY = maxY
            i = dim
            while (i < outerLen):
                x = (data[i] if i >= 0 and i < len(data) else None)
                y = python_internal_ArrayImpl._get(data, (i + 1))
                if (x < minX):
                    minX = x
                if (y < minY):
                    minY = y
                if (x > maxX):
                    maxX = x
                if (y > maxY):
                    maxY = y
                i = (i + dim)
            a = (maxX - minX)
            b = (maxY - minY)
            size = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        hxGeomAlgo_EarCut.earcutLinked(outerNode,triangles,dim,minX,minY,size)
        return triangles

    @staticmethod
    def linkedList(data,start,end,dim,clockwise):
        i = None
        last = None
        if (clockwise == ((hxGeomAlgo_EarCut.signedArea(data,start,end,dim) > 0))):
            i = start
            while (i < end):
                last = hxGeomAlgo_EarCut.insertNode(i,(data[i] if i >= 0 and i < len(data) else None),python_internal_ArrayImpl._get(data, (i + 1)),last)
                i = (i + dim)
        else:
            i = (end - dim)
            while (i >= start):
                last = hxGeomAlgo_EarCut.insertNode(i,(data[i] if i >= 0 and i < len(data) else None),python_internal_ArrayImpl._get(data, (i + 1)),last)
                i = (i - dim)
        tmp = None
        if (last is not None):
            p2 = last.next
            tmp = ((last.x == p2.x) and ((last.y == p2.y)))
        else:
            tmp = False
        if tmp:
            hxGeomAlgo_EarCut.removeNode(last)
            last = last.next
        return last

    @staticmethod
    def filterPoints(start,end = None):
        if (start is None):
            return start
        if (end is None):
            end = start
        p = start
        again = None
        while True:
            again = False
            tmp = None
            if (not p.steiner):
                p2 = p.next
                if (not (((p.x == p2.x) and ((p.y == p2.y))))):
                    p1 = p.prev
                    r = p.next
                    tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) == 0)
                else:
                    tmp = True
            else:
                tmp = False
            if tmp:
                hxGeomAlgo_EarCut.removeNode(p)
                end = p.prev
                p = end
                if (p == p.next):
                    return None
                again = True
            else:
                p = p.next
            if (not ((again or ((p != end))))):
                break
        return end

    @staticmethod
    def earcutLinked(ear,triangles,dim,minX,minY,size,_hx_pass = None):
        if (_hx_pass is None):
            _hx_pass = 0
        if (ear is None):
            return
        if ((_hx_pass == 0) and (not python_lib_Math.isnan(size))):
            hxGeomAlgo_EarCut.indexCurve(ear,minX,minY,size)
        stop = ear
        prev = None
        next = None
        while (ear.prev != ear.next):
            prev = ear.prev
            next = ear.next
            if (hxGeomAlgo_EarCut.isEarHashed(ear,minX,minY,size) if ((not python_lib_Math.isnan(size))) else hxGeomAlgo_EarCut.isEar(ear)):
                x = (prev.i / dim)
                x1 = None
                try:
                    x1 = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e = _hx_e1
                    x1 = None
                triangles.append(x1)
                x2 = (ear.i / dim)
                x3 = None
                try:
                    x3 = int(x2)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e1 = _hx_e1
                    x3 = None
                triangles.append(x3)
                x4 = (next.i / dim)
                x5 = None
                try:
                    x5 = int(x4)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e2 = _hx_e1
                    x5 = None
                triangles.append(x5)
                hxGeomAlgo_EarCut.removeNode(ear)
                ear = next.next
                stop = next.next
                continue
            ear = next
            if (ear == stop):
                if (_hx_pass == 0):
                    hxGeomAlgo_EarCut.earcutLinked(hxGeomAlgo_EarCut.filterPoints(ear),triangles,dim,minX,minY,size,1)
                elif (_hx_pass == 1):
                    ear = hxGeomAlgo_EarCut.cureLocalIntersections(ear,triangles,dim)
                    hxGeomAlgo_EarCut.earcutLinked(ear,triangles,dim,minX,minY,size,2)
                elif (_hx_pass == 2):
                    hxGeomAlgo_EarCut.splitEarcut(ear,triangles,dim,minX,minY,size)
                break

    @staticmethod
    def isEar(ear):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        p = ear.next.next
        while (p != ear.prev):
            tmp = None
            if hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y):
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.next
        return True

    @staticmethod
    def isEarHashed(ear,minX,minY,size):
        a = ear.prev
        b = ear
        c = ear.next
        if (((((b.y - a.y)) * ((c.x - b.x))) - ((((b.x - a.x)) * ((c.y - b.y))))) >= 0):
            return False
        minTX = ((a.x if ((a.x < c.x)) else c.x) if ((a.x < b.x)) else (b.x if ((b.x < c.x)) else c.x))
        minTY = ((a.y if ((a.y < c.y)) else c.y) if ((a.y < b.y)) else (b.y if ((b.y < c.y)) else c.y))
        maxTX = ((a.x if ((a.x > c.x)) else c.x) if ((a.x > b.x)) else (b.x if ((b.x > c.x)) else c.x))
        maxTY = ((a.y if ((a.y > c.y)) else c.y) if ((a.y > b.y)) else (b.y if ((b.y > c.y)) else c.y))
        minZ = hxGeomAlgo_EarCut.zOrder(minTX,minTY,minX,minY,size)
        maxZ = hxGeomAlgo_EarCut.zOrder(maxTX,maxTY,minX,minY,size)
        p = ear.nextZ
        while ((p is not None) and ((p.z <= maxZ))):
            tmp = None
            if (((p != ear.prev) and ((p != ear.next))) and hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)):
                p1 = p.prev
                r = p.next
                tmp = (((((p.y - p1.y)) * ((r.x - p.x))) - ((((p.x - p1.x)) * ((r.y - p.y))))) >= 0)
            else:
                tmp = False
            if tmp:
                return False
            p = p.nextZ
        p = ear.prevZ
        while ((p is not None) and ((p.z >= minZ))):
            tmp1 = None
            if (((p != ear.prev) and ((p != ear.next))) and hxGeomAlgo_EarCut.pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)):
                p2 = p.prev
                r1 = p.next
                tmp1 = (((((p.y - p2.y)) * ((r1.x - p.x))) - ((((p.x - p2.x)) * ((r1.y - p.y))))) >= 0)
            else:
                tmp1 = False
            if tmp1:
                return False
            p = p.prevZ
        return True

    @staticmethod
    def cureLocalIntersections(start,triangles,dim):
        p = start
        while True:
            a = p.prev
            b = p.next.next
            if ((((not (((a.x == b.x) and ((a.y == b.y))))) and hxGeomAlgo_EarCut.intersects(a,p,p.next,b)) and hxGeomAlgo_EarCut.locallyInside(a,b)) and hxGeomAlgo_EarCut.locallyInside(b,a)):
                x = (a.i / dim)
                x1 = None
                try:
                    x1 = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e = _hx_e1
                    x1 = None
                triangles.append(x1)
                x2 = (p.i / dim)
                x3 = None
                try:
                    x3 = int(x2)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e1 = _hx_e1
                    x3 = None
                triangles.append(x3)
                x4 = (b.i / dim)
                x5 = None
                try:
                    x5 = int(x4)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e2 = _hx_e1
                    x5 = None
                triangles.append(x5)
                hxGeomAlgo_EarCut.removeNode(p)
                hxGeomAlgo_EarCut.removeNode(p.next)
                start = b
                p = start
            p = p.next
            if (not ((p != start))):
                break
        return p

    @staticmethod
    def splitEarcut(start,triangles,dim,minX,minY,size):
        a = start
        while True:
            b = a.next.next
            while (b != a.prev):
                if ((a.i != b.i) and hxGeomAlgo_EarCut.isValidDiagonal(a,b)):
                    c = hxGeomAlgo_EarCut.splitPolygon(a,b)
                    a = hxGeomAlgo_EarCut.filterPoints(a,a.next)
                    c = hxGeomAlgo_EarCut.filterPoints(c,c.next)
                    hxGeomAlgo_EarCut.earcutLinked(a,triangles,dim,minX,minY,size)
                    hxGeomAlgo_EarCut.earcutLinked(c,triangles,dim,minX,minY,size)
                    return
                b = b.next
            a = a.next
            if (not ((a != start))):
                break

    @staticmethod
    def eliminateHoles(data,holeIndices,outerNode,dim):
        queue = []
        start = None
        end = None
        _hx_list = None
        i = 0
        _hx_len = len(holeIndices)
        while (i < _hx_len):
            start = ((holeIndices[i] if i >= 0 and i < len(holeIndices) else None) * dim)
            end = ((python_internal_ArrayImpl._get(holeIndices, (i + 1)) * dim) if ((i < ((_hx_len - 1)))) else len(data))
            _hx_list = hxGeomAlgo_EarCut.linkedList(data,start,end,dim,False)
            if (_hx_list == _hx_list.next):
                _hx_list.steiner = True
            x = hxGeomAlgo_EarCut.getLeftmost(_hx_list)
            queue.append(x)
            i = (i + 1)
        haxe_ds_ArraySort.sort(queue,hxGeomAlgo_EarCut.compareX)
        _g = 0
        _g1 = len(queue)
        while (_g < _g1):
            i1 = _g
            _g = (_g + 1)
            hxGeomAlgo_EarCut.eliminateHole((queue[i1] if i1 >= 0 and i1 < len(queue) else None),outerNode)
            outerNode = hxGeomAlgo_EarCut.filterPoints(outerNode,outerNode.next)
        return outerNode

    @staticmethod
    def compareX(a,b):
        x = (a.x - b.x)
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def eliminateHole(hole,outerNode):
        outerNode = hxGeomAlgo_EarCut.findHoleBridge(hole,outerNode)
        if (outerNode is not None):
            b = hxGeomAlgo_EarCut.splitPolygon(outerNode,hole)
            hxGeomAlgo_EarCut.filterPoints(b,b.next)

    @staticmethod
    def findHoleBridge(hole,outerNode):
        p = outerNode
        hx = hole.x
        hy = hole.y
        qx = Math.NEGATIVE_INFINITY
        m = None
        while True:
            if ((hy <= p.y) and ((hy >= p.next.y))):
                x = p.x
                if (p.next.y - p.y) != 0.:
                    x = (p.x + (((((hy - p.y)) * ((p.next.x - p.x))) / ((p.next.y - p.y)))))
                if ((x <= hx) and ((x > qx))):
                    qx = x
                    if (x == hx):
                        if (hy == p.y):
                            return p
                        if (hy == p.next.y):
                            return p.next
                    m = (p if ((p.x < p.next.x)) else p.next)
            p = p.next
            if (not ((p != outerNode))):
                break
        if (m is None):
            return None
        if (hx == qx):
            return m.prev
        stop = m
        mx = m.x
        my = m.y
        tanMin = Math.POSITIVE_INFINITY
        tan = None
        p = m.next
        while (p != stop):
            if (((hx >= p.x) and ((p.x >= mx))) and hxGeomAlgo_EarCut.pointInTriangle((hx if ((hy < my)) else qx),hy,mx,my,(qx if ((hy < my)) else hx),hy,p.x,p.y)):
                tan = (Reflect.field(Math,"fabs")((hy - p.y)) / ((hx - p.x)))
                if ((((tan < tanMin) or (((tan == tanMin) and ((p.x > m.x)))))) and hxGeomAlgo_EarCut.locallyInside(p,hole)):
                    m = p
                    tanMin = tan
            p = p.next
        return m

    @staticmethod
    def indexCurve(start,minX,minY,size):
        p = start
        while True:
            if (p.z is None):
                p.z = hxGeomAlgo_EarCut.zOrder(p.x,p.y,minX,minY,size)
            p.prevZ = p.prev
            p.nextZ = p.next
            p = p.next
            if (not ((p != start))):
                break
        p.prevZ.nextZ = None
        p.prevZ = None
        hxGeomAlgo_EarCut.sortLinked(p)

    @staticmethod
    def sortLinked(_hx_list):
        i = None
        p = None
        q = None
        e = None
        tail = None
        numMerges = None
        pSize = None
        qSize = None
        inSize = 1
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            numMerges = 0
            while (p is not None):
                numMerges = (numMerges + 1)
                q = p
                pSize = 0
                _g = 0
                _g1 = inSize
                while (_g < _g1):
                    i1 = _g
                    _g = (_g + 1)
                    pSize = (pSize + 1)
                    q = q.nextZ
                    if (q is None):
                        break
                qSize = inSize
                while ((pSize > 0) or (((qSize > 0) and ((q is not None))))):
                    if (pSize == 0):
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    elif ((qSize == 0) or ((q is None))):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    elif (p.z <= q.z):
                        e = p
                        p = p.nextZ
                        pSize = (pSize - 1)
                    else:
                        e = q
                        q = q.nextZ
                        qSize = (qSize - 1)
                    if (tail is not None):
                        tail.nextZ = e
                    else:
                        _hx_list = e
                    e.prevZ = tail
                    tail = e
                p = q
            tail.nextZ = None
            inSize = (inSize * 2)
            if (not ((numMerges > 1))):
                break
        return _hx_list

    @staticmethod
    def zOrder(x,y,minX,minY,size):
        _x = None
        try:
            _x = int(((32767 * ((x - minX))) / size))
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            _x = None
        _x1 = _x
        _y = None
        try:
            _y = int(((32767 * ((y - minY))) / size))
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e1 = _hx_e1
            _y = None
        _y1 = _y
        _x1 = (((_x1 | ((_x1 << 8)))) & 16711935)
        _x1 = (((_x1 | ((_x1 << 4)))) & 252645135)
        _x1 = (((_x1 | ((_x1 << 2)))) & 858993459)
        _x1 = (((_x1 | ((_x1 << 1)))) & 1431655765)
        _y1 = (((_y1 | ((_y1 << 8)))) & 16711935)
        _y1 = (((_y1 | ((_y1 << 4)))) & 252645135)
        _y1 = (((_y1 | ((_y1 << 2)))) & 858993459)
        _y1 = (((_y1 | ((_y1 << 1)))) & 1431655765)
        return (_x1 | ((_y1 << 1)))

    @staticmethod
    def getLeftmost(start):
        p = start
        leftmost = start
        while True:
            if (p.x < leftmost.x):
                leftmost = p
            p = p.next
            if (not ((p != start))):
                break
        return leftmost

    @staticmethod
    def pointInTriangle(ax,ay,bx,by,cx,cy,px,py):
        if ((((((cx - px)) * ((ay - py))) - ((((ax - px)) * ((cy - py))))) >= 0) and ((((((ax - px)) * ((by - py))) - ((((bx - px)) * ((ay - py))))) >= 0))):
            return (((((bx - px)) * ((cy - py))) - ((((cx - px)) * ((by - py))))) >= 0)
        else:
            return False

    @staticmethod
    def isValidDiagonal(a,b):
        if (((((a.next.i != b.i) and ((a.prev.i != b.i))) and (not hxGeomAlgo_EarCut.intersectsPolygon(a,b))) and hxGeomAlgo_EarCut.locallyInside(a,b)) and hxGeomAlgo_EarCut.locallyInside(b,a)):
            return hxGeomAlgo_EarCut.middleInside(a,b)
        else:
            return False

    @staticmethod
    def area(p,q,r):
        return ((((q.y - p.y)) * ((r.x - q.x))) - ((((q.x - p.x)) * ((r.y - q.y)))))

    @staticmethod
    def equals(p1,p2):
        if (p1.x == p2.x):
            return (p1.y == p2.y)
        else:
            return False

    @staticmethod
    def intersects(p1,q1,p2,q2):
        if ((((p1.x == q1.x) and ((p1.y == q1.y))) and (((p2.x == q2.x) and ((p2.y == q2.y))))) or ((((p1.x == q2.x) and ((p1.y == q2.y))) and (((p2.x == q1.x) and ((p2.y == q1.y))))))):
            return True
        if ((((((q1.y - p1.y)) * ((p2.x - q1.x))) - ((((q1.x - p1.x)) * ((p2.y - q1.y))))) > 0) != ((((((q1.y - p1.y)) * ((q2.x - q1.x))) - ((((q1.x - p1.x)) * ((q2.y - q1.y))))) > 0))):
            return ((((((q2.y - p2.y)) * ((p1.x - q2.x))) - ((((q2.x - p2.x)) * ((p1.y - q2.y))))) > 0) != ((((((q2.y - p2.y)) * ((q1.x - q2.x))) - ((((q2.x - p2.x)) * ((q1.y - q2.y))))) > 0)))
        else:
            return False

    @staticmethod
    def intersectsPolygon(a,b):
        p = a
        while True:
            if (((((p.i != a.i) and ((p.next.i != a.i))) and ((p.i != b.i))) and ((p.next.i != b.i))) and hxGeomAlgo_EarCut.intersects(p,p.next,a,b)):
                return True
            p = p.next
            if (not ((p != a))):
                break
        return False

    @staticmethod
    def locallyInside(a,b):
        p = a.prev
        r = a.next
        if (((((a.y - p.y)) * ((r.x - a.x))) - ((((a.x - p.x)) * ((r.y - a.y))))) < 0):
            r1 = a.next
            if (((((b.y - a.y)) * ((r1.x - b.x))) - ((((b.x - a.x)) * ((r1.y - b.y))))) >= 0):
                q = a.prev
                return (((((q.y - a.y)) * ((b.x - q.x))) - ((((q.x - a.x)) * ((b.y - q.y))))) >= 0)
            else:
                return False
        else:
            r2 = a.prev
            if (not ((((((b.y - a.y)) * ((r2.x - b.x))) - ((((b.x - a.x)) * ((r2.y - b.y))))) < 0))):
                q1 = a.next
                return (((((q1.y - a.y)) * ((b.x - q1.x))) - ((((q1.x - a.x)) * ((b.y - q1.y))))) < 0)
            else:
                return True

    @staticmethod
    def middleInside(a,b):
        p = a
        inside = False
        px = (((a.x + b.x)) / 2)
        py = (((a.y + b.y)) / 2)
        while True:
            if (((p.y > py) != ((p.next.y > py))) and ((px < ((((((p.next.x - p.x)) * ((py - p.y))) / ((p.next.y - p.y))) + p.x))))):
                inside = (not inside)
            p = p.next
            if (not ((p != a))):
                break
        return inside

    @staticmethod
    def splitPolygon(a,b):
        a2 = hxGeomAlgo_EarNode(a.i,a.x,a.y)
        b2 = hxGeomAlgo_EarNode(b.i,b.x,b.y)
        an = a.next
        bp = b.prev
        a.next = b
        b.prev = a
        a2.next = an
        an.prev = a2
        b2.next = a2
        a2.prev = b2
        bp.next = b2
        b2.prev = bp
        return b2

    @staticmethod
    def insertNode(i,x,y,last = None):
        p = hxGeomAlgo_EarNode(i,x,y)
        if (last is None):
            p.prev = p
            p.next = p
        else:
            p.next = last.next
            p.prev = last
            last.next.prev = p
            last.next = p
        return p

    @staticmethod
    def removeNode(p):
        p.next.prev = p.prev
        p.prev.next = p.next
        if (p.prevZ is not None):
            p.prevZ.nextZ = p.nextZ
        if (p.nextZ is not None):
            p.nextZ.prevZ = p.prevZ

    @staticmethod
    def deviation(data,holeIndices,dim,triangles):
        hasHoles = ((holeIndices is not None) and ((len(holeIndices) > 0)))
        outerLen = (((holeIndices[0] if 0 < len(holeIndices) else None) * dim) if hasHoles else len(data))
        v = hxGeomAlgo_EarCut.signedArea(data,0,outerLen,dim)
        polygonArea = Reflect.field(Math,"fabs")(v)
        if hasHoles:
            i = 0
            _hx_len = len(holeIndices)
            while (i < _hx_len):
                start = ((holeIndices[i] if i >= 0 and i < len(holeIndices) else None) * dim)
                end = ((python_internal_ArrayImpl._get(holeIndices, (i + 1)) * dim) if ((i < ((_hx_len - 1)))) else len(data))
                v1 = hxGeomAlgo_EarCut.signedArea(data,start,end,dim)
                polygonArea = (polygonArea - Reflect.field(Math,"fabs")(v1))
                i = (i + 1)
        trianglesArea = 0.
        i1 = 0
        while (i1 < len(triangles)):
            a = ((triangles[i1] if i1 >= 0 and i1 < len(triangles) else None) * dim)
            b = (python_internal_ArrayImpl._get(triangles, (i1 + 1)) * dim)
            c = (python_internal_ArrayImpl._get(triangles, (i1 + 2)) * dim)
            trianglesArea = (trianglesArea + Reflect.field(Math,"fabs")((((((data[a] if a >= 0 and a < len(data) else None) - (data[c] if c >= 0 and c < len(data) else None))) * ((python_internal_ArrayImpl._get(data, (b + 1)) - python_internal_ArrayImpl._get(data, (a + 1))))) - (((((data[a] if a >= 0 and a < len(data) else None) - (data[b] if b >= 0 and b < len(data) else None))) * ((python_internal_ArrayImpl._get(data, (c + 1)) - python_internal_ArrayImpl._get(data, (a + 1)))))))))
            i1 = (i1 + 3)
        if ((polygonArea == 0) and ((trianglesArea == 0))):
            return 0
        else:
            return Reflect.field(Math,"fabs")((((trianglesArea - polygonArea)) / polygonArea))

    @staticmethod
    def signedArea(data,start,end,dim):
        sum = 0.
        i = start
        j = (end - dim)
        while (i < end):
            sum = (sum + (((((data[j] if j >= 0 and j < len(data) else None) - (data[i] if i >= 0 and i < len(data) else None))) * ((python_internal_ArrayImpl._get(data, (i + 1)) + python_internal_ArrayImpl._get(data, (j + 1)))))))
            j = i
            i = (i + dim)
        return sum

    @staticmethod
    def flatten(data):
        dim = len(python_internal_ArrayImpl._get((data[0] if 0 < len(data) else None), 0))
        result = _hx_AnonObject({'vertices': [], 'holes': [], 'dimensions': dim})
        holeIndex = 0
        _g = 0
        _g1 = len(data)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = len((data[i] if i >= 0 and i < len(data) else None))
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                _g3 = 0
                _g12 = dim
                while (_g3 < _g12):
                    d = _g3
                    _g3 = (_g3 + 1)
                    _this = result.vertices
                    _this.append(python_internal_ArrayImpl._get(python_internal_ArrayImpl._get((data[i] if i >= 0 and i < len(data) else None), j), d))
            if (i > 0):
                holeIndex = (holeIndex + len(python_internal_ArrayImpl._get(data, (i - 1))))
                _this1 = result.holes
                _this1.append(holeIndex)
        return result

    @staticmethod
    def polygonize(triangulation):
        polys = list()
        if (len(triangulation) == 0):
            return []
        else:
            covered = list()
            _g = 0
            _g1 = len(triangulation)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._set(covered, i, False)
            notDone = True
            while notDone:
                poly = None
                currTri = -1
                _g2 = 0
                _g3 = len(triangulation)
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    if (covered[i1] if i1 >= 0 and i1 < len(covered) else None):
                        continue
                    currTri = i1
                    break
                if (currTri == -1):
                    notDone = False
                else:
                    poly = (triangulation[currTri] if currTri >= 0 and currTri < len(triangulation) else None)
                    python_internal_ArrayImpl._set(covered, currTri, True)
                    _g4 = 0
                    _g5 = len(triangulation)
                    while (_g4 < _g5):
                        i2 = _g4
                        _g4 = (_g4 + 1)
                        if (covered[i2] if i2 >= 0 and i2 < len(covered) else None):
                            continue
                        newPoly = hxGeomAlgo_EarCut.addTriangle(poly,(triangulation[i2] if i2 >= 0 and i2 < len(triangulation) else None))
                        if (newPoly is None):
                            continue
                        if hxGeomAlgo_PolyTools.isConvex(newPoly):
                            poly = newPoly
                            python_internal_ArrayImpl._set(covered, i2, True)
                    polys.append(poly)
        return polys

    @staticmethod
    def addTriangle(poly,t):
        firstP = -1
        firstT = -1
        secondP = -1
        secondT = -1
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (((t[0] if 0 < len(t) else None).x == (poly[i] if i >= 0 and i < len(poly) else None).x) and (((t[0] if 0 < len(t) else None).y == (poly[i] if i >= 0 and i < len(poly) else None).y))):
                if (firstP == -1):
                    firstP = i
                    firstT = 0
                else:
                    secondP = i
                    secondT = 0
            elif (((t[1] if 1 < len(t) else None).x == (poly[i] if i >= 0 and i < len(poly) else None).x) and (((t[1] if 1 < len(t) else None).y == (poly[i] if i >= 0 and i < len(poly) else None).y))):
                if (firstP == -1):
                    firstP = i
                    firstT = 1
                else:
                    secondP = i
                    secondT = 1
            elif (((t[2] if 2 < len(t) else None).x == (poly[i] if i >= 0 and i < len(poly) else None).x) and (((t[2] if 2 < len(t) else None).y == (poly[i] if i >= 0 and i < len(poly) else None).y))):
                if (firstP == -1):
                    firstP = i
                    firstT = 2
                else:
                    secondP = i
                    secondT = 2
        if ((firstP == 0) and ((secondP == ((len(poly) - 1))))):
            firstP = (len(poly) - 1)
            secondP = 0
        if (secondP == -1):
            return None
        tipT = 0
        if ((tipT == firstT) or ((tipT == secondT))):
            tipT = 1
        if ((tipT == firstT) or ((tipT == secondT))):
            tipT = 2
        newPoints = list()
        _g2 = 0
        _g3 = len(poly)
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            newPoints.append((poly[i1] if i1 >= 0 and i1 < len(poly) else None))
            if (i1 == firstP):
                newPoints.append((t[tipT] if tipT >= 0 and tipT < len(t) else None))
        return newPoints


class hxGeomAlgo_EarNode:
    _hx_class_name = "hxGeomAlgo.EarNode"
    __slots__ = ("i", "x", "y", "prev", "next", "z", "prevZ", "nextZ", "steiner")
    _hx_fields = ["i", "x", "y", "prev", "next", "z", "prevZ", "nextZ", "steiner"]

    def __init__(self,i,x,y):
        self.i = i
        self.x = x
        self.y = y
        self.prev = None
        self.next = None
        self.z = None
        self.prevZ = None
        self.nextZ = None
        self.steiner = False



class hxGeomAlgo_HomogCoord:
    _hx_class_name = "hxGeomAlgo.HomogCoord"
    __slots__ = ("x", "y", "w")
    _hx_fields = ["x", "y", "w"]
    _hx_methods = ["add", "sub", "neg", "mul", "div", "normalize", "lengthSquared", "length", "perp", "dotPoint", "dot", "perpdot", "dotperp", "equals", "left", "right", "toScreen", "toPoint", "meet", "meetPoint", "toString"]
    _hx_statics = ["INFINITY", "det", "ccw", "cw"]

    def __init__(self,x = None,y = None,w = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (w is None):
            w = 1
        self.x = x
        self.y = y
        self.w = w

    def add(self,p):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p.y)
        _hx_local_2.y
        return self

    def sub(self,p):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 - p.x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 - p.y)
        _hx_local_2.y
        return self

    def neg(self):
        self.w = -self.w
        self.x = -self.x
        self.y = -self.y
        return self

    def mul(self,m):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.w
        _hx_local_0.w = (_hx_local_1 * m)
        _hx_local_0.w
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.x
        _hx_local_2.x = (_hx_local_3 * m)
        _hx_local_2.x
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 * m)
        _hx_local_4.y
        return self

    def div(self,m):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.w
        _hx_local_0.w = (_hx_local_1 / m)
        _hx_local_0.w
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.x
        _hx_local_2.x = (_hx_local_3 / m)
        _hx_local_2.x
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.y
        _hx_local_4.y = (_hx_local_5 / m)
        _hx_local_4.y
        return self

    def normalize(self):
        return self.div(self.length())

    def lengthSquared(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        v = self.lengthSquared()
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    def perp(self):
        tmp = -self.y
        self.y = self.x
        self.x = tmp
        return self

    def dotPoint(self,p):
        return ((self.w + ((self.x * p.x))) + ((self.y * p.y)))

    def dot(self,p):
        return (((self.w * p.w) + ((self.x * p.x))) + ((self.y * p.y)))

    def perpdot(self,p):
        return ((self.x * p.y) - ((self.y * p.x)))

    def dotperp(self,p):
        return ((-self.x * p.y) + ((self.y * p.x)))

    def equals(self,p):
        if ((p.w * self.x) == ((self.w * p.x))):
            return ((p.w * self.y) == ((self.w * p.y)))
        else:
            return False

    def left(self,p):
        return (self.dotPoint(p) > 0)

    def right(self,p):
        return (self.dotPoint(p) < 0)

    def toScreen(self):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new((self.x / self.w),(-self.y / self.w))

    def toPoint(self):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new((self.x / self.w),(self.y / self.w))

    def meet(self,p):
        return hxGeomAlgo_HomogCoord(((p.w * self.y) - ((self.w * p.y))),((self.w * p.x) - ((p.w * self.x))),((self.x * p.y) - ((self.y * p.x))))

    def meetPoint(self,p):
        return hxGeomAlgo_HomogCoord((self.y - ((self.w * p.y))),((self.w * p.x) - self.x),((self.x * p.y) - ((self.y * p.x))))

    def toString(self):
        return ((((((" (w:" + str(self.w)) + "; x:") + str(self.x)) + ", y:") + str(self.y)) + ")  ")

    @staticmethod
    def det(p,q,r):
        return (((p.w * q.perpdot(r)) - ((q.w * p.perpdot(r)))) + ((r.w * p.perpdot(q))))

    @staticmethod
    def ccw(p,q,r):
        return (hxGeomAlgo_HomogCoord.det(p,q,r) > 0)

    @staticmethod
    def cw(p,q,r):
        return (hxGeomAlgo_HomogCoord.det(p,q,r) < 0)



class hxGeomAlgo_HxPointData:
    _hx_class_name = "hxGeomAlgo.HxPointData"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["toString"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def toString(self):
        return (((("(" + str(self.x)) + ", ") + str(self.y)) + ")")



class hxGeomAlgo__HxPoint_HxPoint_Impl_:
    _hx_class_name = "hxGeomAlgo._HxPoint.HxPoint_Impl_"
    __slots__ = ()
    _hx_statics = ["EMPTY", "get_x", "set_x", "get_y", "set_y", "_new", "setTo", "equals", "clone", "toString", "fromPointStruct", "toPointStruct"]
    x = None
    y = None

    @staticmethod
    def get_x(this1):
        return this1.x

    @staticmethod
    def set_x(this1,value):
        def _hx_local_1():
            def _hx_local_0():
                this1.x = value
                return this1.x
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def get_y(this1):
        return this1.y

    @staticmethod
    def set_y(this1,value):
        def _hx_local_1():
            def _hx_local_0():
                this1.y = value
                return this1.y
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _new(x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        this1 = hxGeomAlgo_HxPointData(x,y)
        return this1

    @staticmethod
    def setTo(this1,newX,newY):
        this1.x = newX
        this1.y = newY

    @staticmethod
    def equals(this1,p):
        if ((p is not None) and ((this1.x == p.x))):
            return (this1.y == p.y)
        else:
            return False

    @staticmethod
    def clone(this1):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(this1.x,this1.y)

    @staticmethod
    def toString(this1):
        return (((("(" + str(this1.x)) + ", ") + str(this1.y)) + ")")

    @staticmethod
    def fromPointStruct(p):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(p.x,p.y)

    @staticmethod
    def toPointStruct(this1):
        return _hx_AnonObject({'x': this1.x, 'y': this1.y})


class hxGeomAlgo_PolyTools:
    _hx_class_name = "hxGeomAlgo.PolyTools"
    __slots__ = ()
    _hx_statics = ["point", "zero", "EPSILON", "isCCW", "isCW", "makeCCW", "makeCW", "isConvex", "isSimple", "segmentIntersect", "findDuplicatePoints", "intersection", "isReflex", "at", "wrappedIdx", "side", "isLeft", "isLeftOrOn", "isRight", "isRightOrOn", "isCollinear", "distance", "distanceToSegment", "distanceSquared", "distanceToSegmentSquared", "getCentroid", "getArea", "meet", "dot", "sqr", "eq", "clear", "toFloatArray", "reverseFloatArray", "flatten", "toPointArray", "parsePoints", "inflateLine", "clip", "lerp", "lerpPoints", "exposeEnum"]

    @staticmethod
    def isCCW(poly):
        if (len(poly) <= 2):
            return True
        signedArea = 0.
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            idx = (i - 1)
            idx1 = idx
            _hx_len = len(poly)
            if (idx1 < 0):
                idx1 = (idx1 + _hx_len)
            idx = HxOverrides.mod(idx1, _hx_len)
            idx2 = (i - 1)
            idx3 = idx2
            len1 = len(poly)
            if (idx3 < 0):
                idx3 = (idx3 + len1)
            idx2 = HxOverrides.mod(idx3, len1)
            signedArea = (signedArea + ((((poly[idx] if idx >= 0 and idx < len(poly) else None).x * (poly[i] if i >= 0 and i < len(poly) else None).y) - (((poly[i] if i >= 0 and i < len(poly) else None).x * (poly[idx2] if idx2 >= 0 and idx2 < len(poly) else None).y)))))
        return (signedArea < 0)

    @staticmethod
    def isCW(poly):
        if (len(poly) <= 2):
            return True
        signedArea = 0.
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            idx = (i - 1)
            idx1 = idx
            _hx_len = len(poly)
            if (idx1 < 0):
                idx1 = (idx1 + _hx_len)
            idx = HxOverrides.mod(idx1, _hx_len)
            idx2 = (i - 1)
            idx3 = idx2
            len1 = len(poly)
            if (idx3 < 0):
                idx3 = (idx3 + len1)
            idx2 = HxOverrides.mod(idx3, len1)
            signedArea = (signedArea + ((((poly[idx] if idx >= 0 and idx < len(poly) else None).x * (poly[i] if i >= 0 and i < len(poly) else None).y) - (((poly[i] if i >= 0 and i < len(poly) else None).x * (poly[idx2] if idx2 >= 0 and idx2 < len(poly) else None).y)))))
        return (signedArea > 0)

    @staticmethod
    def makeCCW(poly):
        reversed = False
        if (not hxGeomAlgo_PolyTools.isCCW(poly)):
            poly.reverse()
            reversed = True
        return reversed

    @staticmethod
    def makeCW(poly):
        reversed = False
        if hxGeomAlgo_PolyTools.isCCW(poly):
            poly.reverse()
            reversed = True
        return reversed

    @staticmethod
    def isConvex(poly):
        isPositive = None
        _g = 0
        _g1 = len(poly)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            lower = ((len(poly) - 1) if ((i == 0)) else (i - 1))
            middle = i
            upper = (0 if ((i == ((len(poly) - 1)))) else (i + 1))
            dx0 = ((poly[middle] if middle >= 0 and middle < len(poly) else None).x - (poly[lower] if lower >= 0 and lower < len(poly) else None).x)
            dy0 = ((poly[middle] if middle >= 0 and middle < len(poly) else None).y - (poly[lower] if lower >= 0 and lower < len(poly) else None).y)
            dx1 = ((poly[upper] if upper >= 0 and upper < len(poly) else None).x - (poly[middle] if middle >= 0 and middle < len(poly) else None).x)
            dy1 = ((poly[upper] if upper >= 0 and upper < len(poly) else None).y - (poly[middle] if middle >= 0 and middle < len(poly) else None).y)
            cross = ((dx0 * dy1) - ((dx1 * dy0)))
            newIsPositive = (cross > 0)
            if (cross == 0):
                continue
            if (isPositive is None):
                isPositive = newIsPositive
            elif (isPositive != newIsPositive):
                return False
        return True

    @staticmethod
    def isSimple(poly):
        _hx_len = len(poly)
        if (_hx_len <= 3):
            return True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = i
            p1 = (0 if ((i == ((_hx_len - 1)))) else (i + 1))
            _g2 = (i + 1)
            _g11 = _hx_len
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                q0 = j
                q1 = (0 if ((j == ((_hx_len - 1)))) else (j + 1))
                intersection = hxGeomAlgo_PolyTools.segmentIntersect((poly[p0] if p0 >= 0 and p0 < len(poly) else None),(poly[p1] if p1 >= 0 and p1 < len(poly) else None),(poly[q0] if q0 >= 0 and q0 < len(poly) else None),(poly[q1] if q1 >= 0 and q1 < len(poly) else None))
                tmp = None
                tmp1 = None
                if (intersection is not None):
                    tmp2 = None
                    w = (poly[p0] if p0 >= 0 and p0 < len(poly) else None)
                    x = (intersection.x - w.x)
                    x1 = (intersection.y - w.y)
                    v = ((x * x) + ((x1 * x1)))
                    if (not ((((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))) < hxGeomAlgo_PolyTools.EPSILON))):
                        w1 = (poly[p1] if p1 >= 0 and p1 < len(poly) else None)
                        x2 = (intersection.x - w1.x)
                        x3 = (intersection.y - w1.y)
                        v1 = ((x2 * x2) + ((x3 * x3)))
                        tmp2 = (((Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))) < hxGeomAlgo_PolyTools.EPSILON)
                    else:
                        tmp2 = True
                    tmp1 = (not tmp2)
                else:
                    tmp1 = False
                if tmp1:
                    tmp3 = None
                    w2 = (poly[q0] if q0 >= 0 and q0 < len(poly) else None)
                    x4 = (intersection.x - w2.x)
                    x5 = (intersection.y - w2.y)
                    v2 = ((x4 * x4) + ((x5 * x5)))
                    if (not ((((Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))) < hxGeomAlgo_PolyTools.EPSILON))):
                        w3 = (poly[q1] if q1 >= 0 and q1 < len(poly) else None)
                        x6 = (intersection.x - w3.x)
                        x7 = (intersection.y - w3.y)
                        v3 = ((x6 * x6) + ((x7 * x7)))
                        tmp3 = (((Math.NaN if ((v3 < 0)) else python_lib_Math.sqrt(v3))) < hxGeomAlgo_PolyTools.EPSILON)
                    else:
                        tmp3 = True
                    tmp = (not tmp3)
                else:
                    tmp = False
                if tmp:
                    return False
        return True

    @staticmethod
    def segmentIntersect(p0,p1,q0,q1):
        a1 = (p1.y - p0.y)
        b1 = (p0.x - p1.x)
        c1 = ((p1.x * p0.y) - ((p0.x * p1.y)))
        a2 = (q1.y - q0.y)
        b2 = (q0.x - q1.x)
        c2 = ((q1.x * q0.y) - ((q0.x * q1.y)))
        denom = ((a1 * b2) - ((a2 * b1)))
        if (denom == 0):
            return None
        intersectionPoint = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
        intersectionPoint.x = ((((b1 * c2) - ((b2 * c1)))) / denom)
        intersectionPoint.y = ((((a2 * c1) - ((a1 * c2)))) / denom)
        x = (p0.x - p1.x)
        x1 = (p0.y - p1.y)
        p0p1 = ((x * x) + ((x1 * x1)))
        x2 = (q0.x - q1.x)
        x3 = (q0.y - q1.y)
        q0q1 = ((x2 * x2) + ((x3 * x3)))
        x4 = (intersectionPoint.x - p1.x)
        x5 = (intersectionPoint.y - p1.y)
        if (((x4 * x4) + ((x5 * x5))) > p0p1):
            return None
        x6 = (intersectionPoint.x - p0.x)
        x7 = (intersectionPoint.y - p0.y)
        if (((x6 * x6) + ((x7 * x7))) > p0p1):
            return None
        x8 = (intersectionPoint.x - q1.x)
        x9 = (intersectionPoint.y - q1.y)
        if (((x8 * x8) + ((x9 * x9))) > q0q1):
            return None
        x10 = (intersectionPoint.x - q0.x)
        x11 = (intersectionPoint.y - q0.y)
        if (((x10 * x10) + ((x11 * x11))) > q0q1):
            return None
        return intersectionPoint

    @staticmethod
    def findDuplicatePoints(poly,consecutiveOnly = None,wrapAround = None):
        if (consecutiveOnly is None):
            consecutiveOnly = True
        if (wrapAround is None):
            wrapAround = True
        _hx_len = len(poly)
        if (_hx_len <= 1):
            return []
        dupIndices = []
        _g = 0
        _g1 = (_hx_len - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            j = (i + 1)
            while (j < _hx_len):
                this1 = (poly[i] if i >= 0 and i < len(poly) else None)
                p = (poly[j] if j >= 0 and j < len(poly) else None)
                foundDup = (((p is not None) and ((this1.x == p.x))) and ((this1.y == p.y)))
                if foundDup:
                    dupIndices.append(i)
                if (consecutiveOnly or ((foundDup and (not consecutiveOnly)))):
                    break
                j = (j + 1)
        tmp = None
        if (wrapAround and consecutiveOnly):
            this2 = (poly[0] if 0 < len(poly) else None)
            p1 = python_internal_ArrayImpl._get(poly, (_hx_len - 1))
            tmp = (((p1 is not None) and ((this2.x == p1.x))) and ((this2.y == p1.y)))
        else:
            tmp = False
        if tmp:
            dupIndices.append((_hx_len - 1))
        return dupIndices

    @staticmethod
    def intersection(p1,p2,q1,q2):
        res = None
        a1 = (p2.y - p1.y)
        b1 = (p1.x - p2.x)
        c1 = ((a1 * p1.x) + ((b1 * p1.y)))
        a2 = (q2.y - q1.y)
        b2 = (q1.x - q2.x)
        c2 = ((a2 * q1.x) + ((b2 * q1.y)))
        det = ((a1 * b2) - ((a2 * b1)))
        if (not ((Reflect.field(Math,"fabs")(det) <= hxGeomAlgo_PolyTools.EPSILON))):
            res = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
            res.x = ((((b2 * c1) - ((b1 * c2)))) / det)
            res.y = ((((a1 * c2) - ((a2 * c1)))) / det)
        return res

    @staticmethod
    def isReflex(poly,idx):
        idx1 = (idx - 1)
        idx2 = idx1
        _hx_len = len(poly)
        if (idx2 < 0):
            idx2 = (idx2 + _hx_len)
        idx1 = HxOverrides.mod(idx2, _hx_len)
        p = (poly[idx1] if idx1 >= 0 and idx1 < len(poly) else None)
        idx3 = idx
        idx4 = idx3
        len1 = len(poly)
        if (idx4 < 0):
            idx4 = (idx4 + len1)
        idx3 = HxOverrides.mod(idx4, len1)
        a = (poly[idx3] if idx3 >= 0 and idx3 < len(poly) else None)
        idx5 = (idx + 1)
        idx6 = idx5
        len2 = len(poly)
        if (idx6 < 0):
            idx6 = (idx6 + len2)
        idx5 = HxOverrides.mod(idx6, len2)
        b = (poly[idx5] if idx5 >= 0 and idx5 < len(poly) else None)
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) < 0)

    @staticmethod
    def at(poly,idx):
        idx1 = idx
        _hx_len = len(poly)
        if (idx1 < 0):
            idx1 = (idx1 + _hx_len)
        idx = HxOverrides.mod(idx1, _hx_len)
        return (poly[idx] if idx >= 0 and idx < len(poly) else None)

    @staticmethod
    def wrappedIdx(poly,idx):
        _hx_len = len(poly)
        if (idx < 0):
            idx = (idx + _hx_len)
        return HxOverrides.mod(idx, _hx_len)

    @staticmethod
    def side(p,a,b):
        return ((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y)))))

    @staticmethod
    def isLeft(p,a,b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) > 0)

    @staticmethod
    def isLeftOrOn(p,a,b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) >= 0)

    @staticmethod
    def isRight(p,a,b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) < 0)

    @staticmethod
    def isRightOrOn(p,a,b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) <= 0)

    @staticmethod
    def isCollinear(p,a,b):
        return (((((a.x - p.x)) * ((b.y - p.y))) - ((((b.x - p.x)) * ((a.y - p.y))))) == 0)

    @staticmethod
    def distance(v,w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        v1 = ((x * x) + ((x1 * x1)))
        if (v1 < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v1)

    @staticmethod
    def distanceToSegment(p,v,w):
        v1 = hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w)
        if (v1 < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v1)

    @staticmethod
    def distanceSquared(v,w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        return ((x * x) + ((x1 * x1)))

    @staticmethod
    def distanceToSegmentSquared(p,v,w):
        x = (v.x - w.x)
        x1 = (v.y - w.y)
        l2 = ((x * x) + ((x1 * x1)))
        if (l2 == 0):
            x2 = (p.x - v.x)
            x3 = (p.y - v.y)
            return ((x2 * x2) + ((x3 * x3)))
        t = ((((((p.x - v.x)) * ((w.x - v.x))) + ((((p.y - v.y)) * ((w.y - v.y)))))) / l2)
        if (t < 0):
            x4 = (p.x - v.x)
            x5 = (p.y - v.y)
            return ((x4 * x4) + ((x5 * x5)))
        if (t > 1):
            x6 = (p.x - w.x)
            x7 = (p.y - w.y)
            return ((x6 * x6) + ((x7 * x7)))
        this1 = hxGeomAlgo_PolyTools.point
        this1.x = (v.x + ((t * ((w.x - v.x)))))
        this1.y = (v.y + ((t * ((w.y - v.y)))))
        w1 = hxGeomAlgo_PolyTools.point
        x8 = (p.x - w1.x)
        x9 = (p.y - w1.y)
        return ((x8 * x8) + ((x9 * x9)))

    @staticmethod
    def getCentroid(poly):
        c = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
        area = hxGeomAlgo_PolyTools.getArea(poly)
        if (area != 0):
            _hx_len = len(poly)
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                p0 = (poly[i] if i >= 0 and i < len(poly) else None)
                p1 = python_internal_ArrayImpl._get(poly, HxOverrides.mod(((i + 1)), _hx_len))
                m = ((p0.x * p1.y) - ((p1.x * p0.y)))
                _hx_local_0 = c
                _hx_local_1 = _hx_local_0.x
                _hx_local_0.x = (_hx_local_1 + ((((p0.x + p1.x)) * m)))
                _hx_local_0.x
                _hx_local_2 = c
                _hx_local_3 = _hx_local_2.y
                _hx_local_2.y = (_hx_local_3 + ((((p0.y + p1.y)) * m)))
                _hx_local_2.y
            _hx_local_4 = c
            _hx_local_5 = _hx_local_4.x
            _hx_local_4.x = (_hx_local_5 / ((6 * area)))
            _hx_local_4.x
            _hx_local_6 = c
            _hx_local_7 = _hx_local_6.y
            _hx_local_6.y = (_hx_local_7 / ((6 * area)))
            _hx_local_6.y
        else:
            c = hxGeomAlgo__HxPoint_HxPoint_Impl_.EMPTY
        return c

    @staticmethod
    def getArea(poly):
        area = 0.0
        _hx_len = len(poly)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p0 = (poly[i] if i >= 0 and i < len(poly) else None)
            p1 = python_internal_ArrayImpl._get(poly, HxOverrides.mod(((i + 1)), _hx_len))
            area = (area + (((p0.x * p1.y) - ((p1.x * p0.y)))))
        area = (.5 * area)
        return area

    @staticmethod
    def meet(p,q):
        return hxGeomAlgo_HomogCoord((p.y - q.y),(q.x - p.x),((p.x * q.y) - ((p.y * q.x))))

    @staticmethod
    def dot(p,q):
        return ((p.x * q.x) + ((p.y * q.y)))

    @staticmethod
    def sqr(x):
        return (x * x)

    @staticmethod
    def eq(a,b):
        return (Reflect.field(Math,"fabs")((a - b)) <= hxGeomAlgo_PolyTools.EPSILON)

    @staticmethod
    def clear(array):
        array = []

    @staticmethod
    def toFloatArray(poly,out = None):
        out = (out if ((out is not None)) else list())
        _g = 0
        while (_g < len(poly)):
            p = (poly[_g] if _g >= 0 and _g < len(poly) else None)
            _g = (_g + 1)
            x = p.x
            out.append(x)
            x1 = p.y
            out.append(x1)
        return out

    @staticmethod
    def reverseFloatArray(poly,inPlace = None):
        if (inPlace is None):
            inPlace = False
        res = (poly if inPlace else list())
        nPoints = (len(poly) >> 1)
        _g = 0
        _g1 = nPoints
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            xPos = ((((nPoints - i) - 1)) * 2)
            python_internal_ArrayImpl._set(res, (i * 2), (poly[xPos] if xPos >= 0 and xPos < len(poly) else None))
            python_internal_ArrayImpl._set(res, ((i * 2) + 1), python_internal_ArrayImpl._get(poly, (xPos + 1)))
        return res

    @staticmethod
    def flatten(array,out = None):
        res = (out if ((out is not None)) else [])
        _g = 0
        while (_g < len(array)):
            arr = (array[_g] if _g >= 0 and _g < len(array) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(arr)):
                item = (arr[_g1] if _g1 >= 0 and _g1 < len(arr) else None)
                _g1 = (_g1 + 1)
                res.append(item)
        return res

    @staticmethod
    def toPointArray(poly,out = None):
        out = (out if ((out is not None)) else list())
        size = len(poly)
        if (HxOverrides.mod(len(poly), 2) == 1):
            size = (size - 1)
        _g = 0
        _g1 = (size >> 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(python_internal_ArrayImpl._get(poly, (i * 2)),python_internal_ArrayImpl._get(poly, ((i * 2) + 1)))
            out.append(x)
        return out

    @staticmethod
    def parsePoints(_hx_str):
        def _hx_local_0(val):
            if (val is not None):
                return (val != "")
            else:
                return False
        floats = list(map(Std.parseFloat,list(filter(_hx_local_0,EReg("[^-eE\\.\\d]+","g").split(_hx_str)))))
        pts = list()
        n = len(floats)
        _g = 0
        _g1 = None
        try:
            _g1 = int((n / 2))
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e = _hx_e1
            _g1 = None
        _g11 = _g1
        while (_g < _g11):
            i = _g
            _g = (_g + 1)
            x = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(python_internal_ArrayImpl._get(floats, (i * 2)),python_internal_ArrayImpl._get(floats, ((i * 2) + 1)))
            pts.append(x)
        return pts

    @staticmethod
    def inflateLine(start,end,thickness):
        halfWidth = (thickness / 2)
        dx = (end.x - start.x)
        dy = (end.y - start.y)
        v = ((dx * dx) + ((dy * dy)))
        _hx_len = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        nx = ((dx / _hx_len) * halfWidth)
        ny = ((dy / _hx_len) * halfWidth)
        return [hxGeomAlgo__HxPoint_HxPoint_Impl_._new((start.x - ny),(start.y + nx)), hxGeomAlgo__HxPoint_HxPoint_Impl_._new((end.x - ny),(end.y + nx)), hxGeomAlgo__HxPoint_HxPoint_Impl_._new((end.x + ny),(end.y - nx)), hxGeomAlgo__HxPoint_HxPoint_Impl_._new((start.x + ny),(start.y - nx))]

    @staticmethod
    def clip(subjPoly,clipPoly):
        cond = ((len(clipPoly) >= 3) and hxGeomAlgo_PolyTools.isConvex(clipPoly))
        res = []
        output = subjPoly
        isInside = (hxGeomAlgo_PolyTools.isRight if (hxGeomAlgo_PolyTools.isCCW(clipPoly)) else hxGeomAlgo_PolyTools.isLeft)
        clipEdgeStart = None
        clipEdgeEnd = None
        inputEdgeStart = None
        inputEdgeEnd = None
        clipLen = len(clipPoly)
        _g = 0
        _g1 = clipLen
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            clipEdgeStart = (clipPoly[i] if i >= 0 and i < len(clipPoly) else None)
            idx = (i + 1)
            _hx_len = len(clipPoly)
            if (idx < 0):
                idx = (idx + _hx_len)
            clipEdgeEnd = python_internal_ArrayImpl._get(clipPoly, HxOverrides.mod(idx, _hx_len))
            input = output
            output = []
            inputEdgeStart = python_internal_ArrayImpl._get(input, (len(input) - 1))
            _g2 = 0
            _g11 = len(input)
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                inputEdgeEnd = (input[j] if j >= 0 and j < len(input) else None)
                if isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd):
                    if (not isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)):
                        intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd)
                        if (intersectionPoint is not None):
                            output.append(intersectionPoint)
                    output.append(inputEdgeEnd)
                elif isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd):
                    intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd)
                    if (intersectionPoint1 is not None):
                        output.append(intersectionPoint1)
                inputEdgeStart = inputEdgeEnd
            res.append(output)
        return res

    @staticmethod
    def lerp(a,b,t):
        return ((((1.0 - t)) * a) + ((t * b)))

    @staticmethod
    def lerpPoints(a,b,t):
        return hxGeomAlgo__HxPoint_HxPoint_Impl_._new(((((1.0 - t)) * a.x) + ((t * b.x))),((((1.0 - t)) * a.y) + ((t * b.y))))

    @staticmethod
    def exposeEnum(enumClass,_hx_as = None):
        pass


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            pass
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1(o2.params[i1],s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "modf", "mod"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

hxGeomAlgo_HomogCoord.INFINITY = hxGeomAlgo_HomogCoord()
hxGeomAlgo__HxPoint_HxPoint_Impl_.EMPTY = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(Math.NaN,Math.NaN)
hxGeomAlgo_PolyTools.point = hxGeomAlgo__HxPoint_HxPoint_Impl_._new()
hxGeomAlgo_PolyTools.zero = hxGeomAlgo__HxPoint_HxPoint_Impl_._new(0,0)
hxGeomAlgo_PolyTools.EPSILON = .00000001
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
